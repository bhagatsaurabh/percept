// Generated by dts-bundle-generator v6.9.0

export declare enum Handle {
	AUTO = -1
}
export declare enum Constant {
	TAU
}
export declare class Color {
	static Random(): string;
	static rgbToHex(rgb: number[] | Uint8ClampedArray): string;
	private static _componentToHex;
}
export declare class Debug {
	static debugPoint(key: string, drawing: Drawing, point: Vector, props: {
		color: string;
		radius?: number;
	}, frames?: number): void;
	private static _debugPoint;
	static debugLine(key: string, drawing: Drawing, from: Vector, to: Vector, props: {
		color: string;
		width?: number;
	}, frames?: number): void;
	private static _debugLine;
	static show(debugCalls: Record<string, DebugCall[]>, context: CanvasRenderingContext2D): void;
	private static limitDebugCalls;
}
export interface Event {
	registeredEvents: any;
	on(eventKey: string, callback: Function): void;
}
export declare class Dimension {
	width: number;
	height: number;
	constructor(width: number, height: number);
	max(): number;
}
export declare class Matrix {
	value: number[][];
	constructor(value: number[][]);
	private _multiply;
	multiply(another: Matrix | number[][]): Matrix;
	multiplyInPlace(another: Matrix | number[][]): Matrix;
	clone(): Matrix;
	getRotation(): number;
	static Identity(): Matrix;
	static Zero(): Matrix;
	static Multiply(matrix1: number[][], matrix2: number[][]): any[][];
}
export declare class Transform {
	node: Node;
	refControlPoints: Vector[];
	controlPoints: Vector[];
	localTrasform: Matrix;
	worldTransform: Matrix;
	childs: Transform[];
	private _parent;
	private _position;
	private _localRotation;
	private _rotation;
	private _scale;
	get parent(): Transform;
	set parent(newParent: Transform);
	get position(): Vector;
	set position(newPosition: Vector);
	get absolutePosition(): Vector;
	get rotation(): number;
	set rotation(degrees: number);
	get localRotation(): number;
	set localRotation(newRotation: number);
	get scale(): Vector;
	set scale(newScale: Vector);
	constructor(position: Vector, localRotation: number, rotation: number, scale: Vector, controlPoints: Vector[], node: Node);
	private relativeControlPoints;
	private applyTransform;
	private _updateWorldTransform;
	updateWorldTransform(parentWorldTransform?: Matrix): void;
}
export declare abstract class Node implements Event {
	id: string;
	drawing: Drawing;
	context: CanvasRenderingContext2D;
	offContext: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D;
	transform: Transform;
	registeredEvents: any;
	order: number;
	hitColor: string;
	abstract _render(): void;
	abstract _offRender(): void;
	abstract getDimension(): Vector;
	get zIndex(): number;
	set zIndex(zIndex: number);
	get parent(): Node;
	set parent(newParent: Node);
	get childs(): Node[];
	get position(): Vector;
	set position(position: Vector);
	get absolutePosition(): Vector;
	get rotation(): number;
	set rotation(degrees: number);
	get localRotation(): number;
	set localRotation(degrees: number);
	get scale(): Vector;
	set scale(scale: Vector);
	constructor(id: string, position: Vector, controlPoints: Vector[]);
	setHitColor(): void;
	on(eventKey: string, callback: Function): void;
	render(): void;
	offRender(): void;
	call(method: string, args?: any[]): void;
	setContext(context: CanvasRenderingContext2D, offContext: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D): void;
	setDrawing(drawing: Drawing): void;
	dispose(): void;
}
export interface DebugCall {
	debugFunction: Function;
	arguments: any[];
	frames?: number;
}
export declare class Drawing {
	canvas: Canvas;
	globalUpdate?: Function;
	private sceneGraph;
	debugCalls: Record<string, DebugCall[]>;
	colorToNode: {
		[key: string]: Node;
	};
	pointers: any[];
	constructor(canvas: Canvas, globalUpdate?: Function);
	private getRelativePosition;
	private updatePointer;
	private removePointer;
	private _registerEvents;
	private _getHitNode;
	render(): void;
	add(node: Node | Node[]): void;
	remove(nodeOrID: Node | string): void;
	private _debugSceneGraph;
}
export declare class Canvas {
	canvasElement: HTMLCanvasElement;
	context: CanvasRenderingContext2D;
	offCanvasElement: OffscreenCanvas | HTMLCanvasElement;
	offContext: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D;
	currDrawing: Drawing;
	private frameId;
	private canvasObserver;
	get width(): number;
	get height(): number;
	constructor(element?: HTMLCanvasElement | HTMLDivElement, width?: number, height?: number);
	private registerObservers;
	draw(drawing: Drawing): void;
	stop(): void;
	resume(): void;
	private render;
}
export declare class Vector {
	x: number;
	y: number;
	tmpX: number;
	tmpY: number;
	constructor(x: number, y: number);
	toString(): string;
	add(x: number, y: number): Vector;
	add(value: number): Vector;
	add(vector: Vector): Vector;
	addInPlace(x: number, y: number): Vector;
	addInPlace(value: number): Vector;
	addInPlace(vector: Vector): Vector;
	multiply(x: number, y: number): Vector;
	multiply(value: number): Vector;
	multiply(vector: Vector): Vector;
	multiplyInPlace(x: number, y: number): Vector;
	multiplyInPlace(value: number): Vector;
	multiplyInPlace(vector: Vector): Vector;
	subtract(x: number, y: number): Vector;
	subtract(value: number): Vector;
	subtract(vector: Vector): Vector;
	subtractInPlace(x: number, y: number): Vector;
	subtractInPlace(value: number): Vector;
	subtractInPlace(vector: Vector): Vector;
	rotate(pivot: Vector, degrees: number): Vector;
	rotateInPlace(pivot: Vector, degrees: number): Vector;
	transform(matrix: Matrix): Vector;
	transformInPlace(matrix: Matrix): Vector;
	max(): number;
	static Midpoint(vector1: Vector, vector2: Vector): Vector;
	static Distance(vector1: Vector, vector2: Vector): number;
	static Zero(): Vector;
	static Unit(): Vector;
	static Bounds(vectors: Vector[]): Vector[];
	static Average(vectors: Vector[]): Vector;
	static Random(canvas: Canvas): Vector;
	static Random(minX: number, maxX: number, minY: number, maxY: number): Vector;
	static Lerp(start: Vector, end: Vector, amount: number): Vector;
	clone(): Vector;
}

export {};
