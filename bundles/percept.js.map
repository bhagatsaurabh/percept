{"version":3,"file":"percept.js","mappings":"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","sources":["webpack://Percept/webpack/universalModuleDefinition","webpack://Percept/./src/common/constants.ts","webpack://Percept/./src/common/enums.ts","webpack://Percept/./src/common/index.ts","webpack://Percept/./src/core/canvas.ts","webpack://Percept/./src/core/color.ts","webpack://Percept/./src/core/debug.ts","webpack://Percept/./src/core/drawing.ts","webpack://Percept/./src/core/index.ts","webpack://Percept/./src/core/node.ts","webpack://Percept/./src/math/dimension.ts","webpack://Percept/./src/math/index.ts","webpack://Percept/./src/math/matrix.ts","webpack://Percept/./src/math/transform.ts","webpack://Percept/./src/math/vector.ts","webpack://Percept/./src/percept.ts","webpack://Percept/./src/view/ellipse.ts","webpack://Percept/./src/view/empty.ts","webpack://Percept/./src/view/image.ts","webpack://Percept/./src/view/index.ts","webpack://Percept/./src/view/line.ts","webpack://Percept/./src/view/linear-gradient.ts","webpack://Percept/./src/view/polygon.ts","webpack://Percept/./src/view/radial-gradient.ts","webpack://Percept/./src/view/rectangle.ts","webpack://Percept/./src/view/text.ts","webpack://Percept/webpack/bootstrap","webpack://Percept/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Percept\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Percept\"] = factory();\n\telse\n\t\troot[\"Percept\"] = factory();\n})(self, () => {\nreturn ","export enum Constant {\r\n  TAU = Math.PI / 180,\r\n}\r\n","export enum Handle {\r\n  AUTO = -1,\r\n}\r\n","export * from \"./enums\";\r\nexport * from \"./constants\";\r\n","import { Drawing } from \"./drawing\";\n\n/**\n * The Canvas object holds an HTMLCanvasElement reference and its 2d context\n */\nexport class Canvas {\n  canvasElement: HTMLCanvasElement;\n  context: CanvasRenderingContext2D;\n  offCanvasElement: OffscreenCanvas | HTMLCanvasElement;\n  offContext: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D;\n\n  currDrawing: Drawing;\n  private frameId: number = 0;\n  private canvasObserver: MutationObserver;\n\n  get width(): number {\n    return this.canvasElement?.width;\n  }\n  get height(): number {\n    return this.canvasElement?.height;\n  }\n\n  /**\n   * If no parameters are passed then a new canvas element will be created and appended to `<body>`\n   *\n   * @param element Reference to an html `<canvas>` or `<div>` element, if a `<div>` element is passed, then a canvas will be created and appended\n   * @param width Passing a width will overwrite previously defined canvas width\n   * @param height Passing a height will overwrite previously defined canvas height\n   */\n  constructor(\n    element?: HTMLCanvasElement | HTMLDivElement,\n    width?: number,\n    height?: number\n  ) {\n    if (!element) {\n      this.canvasElement = document.createElement(\"canvas\");\n      this.canvasElement.width = document.body.clientWidth;\n      this.canvasElement.height = document.body.clientHeight;\n      document.body.appendChild(this.canvasElement);\n    } else {\n      if (element instanceof HTMLDivElement) {\n        this.canvasElement = document.createElement(\"canvas\");\n        if (width && height) {\n          this.canvasElement.width = width;\n          this.canvasElement.height = height;\n        } else {\n          this.canvasElement.width = element.clientWidth;\n          this.canvasElement.height = element.clientHeight;\n        }\n        element.appendChild(this.canvasElement);\n      } else {\n        this.canvasElement = element;\n        if (width && height) {\n          this.canvasElement.width = width;\n          this.canvasElement.height = height;\n        }\n      }\n    }\n    this.context = this.canvasElement.getContext(\"2d\");\n\n    if (typeof OffscreenCanvas !== \"undefined\") {\n      this.offCanvasElement = new OffscreenCanvas(this.width, this.height);\n      this.offContext = this.offCanvasElement.getContext(\"2d\");\n    } else {\n      this.offCanvasElement = document.createElement(\"canvas\");\n      this.offCanvasElement.width = this.width;\n      this.offCanvasElement.height = this.height;\n      this.offContext = this.offCanvasElement.getContext(\"2d\");\n    }\n\n    this.registerObservers();\n  }\n\n  /* istanbul ignore next */\n  private registerObservers() {\n    this.canvasObserver = new MutationObserver((mutations) => {\n      mutations.forEach((mutation) => {\n        if (\n          mutation.type === \"attributes\" &&\n          (mutation.attributeName === \"width\" ||\n            mutation.attributeName === \"height\")\n        ) {\n          this.draw(this.currDrawing);\n        }\n      });\n    });\n\n    this.canvasObserver.observe(this.canvasElement, { attributes: true });\n  }\n\n  /**\n   * Calls render function of `Drawing`\n   *\n   * @param drawing A `Drawing` object, which will be rendered by this canvas\n   */\n  draw(drawing: Drawing) {\n    this.stop();\n    this.render(drawing);\n  }\n\n  /**\n   * Stops rendering current Drawing\n   */\n  stop() {\n    window.cancelAnimationFrame(this.frameId);\n  }\n\n  /* istanbul ignore next */\n  private render(drawing: Drawing) {\n    this.currDrawing = drawing;\n    drawing.render();\n    if (this.frameId < 0) return;\n    this.frameId = window.requestAnimationFrame(\n      this.render.bind(this, drawing)\n    );\n  }\n}\n","export class Color {\r\n  static Random(): string {\r\n    return \"#\" + Math.floor(Math.random() * 16777215).toString(16);\r\n  }\r\n\r\n  static rgbToHex(rgb: number[] | Uint8ClampedArray): string {\r\n    return (\r\n      \"#\" +\r\n      Color._componentToHex(rgb[0]) +\r\n      Color._componentToHex(rgb[1]) +\r\n      Color._componentToHex(rgb[2])\r\n    );\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  private static _componentToHex(c: number) {\r\n    let hex = c.toString(16);\r\n    return hex.length == 1 ? \"0\" + hex : hex;\r\n  }\r\n}\r\n","import { Drawing, DebugCall } from \".\";\nimport { Vector } from \"../math/vector\";\n\n/**\n * Includes static methods for debugging\n */\nexport class Debug {\n  /**\n   * Will render a filled circle denoting a single point on canvas\n   *\n   * @param key A unique name for this debug\n   * @param drawing Drawing, on which this debug will render\n   * @param point The point to render\n   * @param props Styling properties for debug\n   * @param frames Specifies for how many frames this debug will persist (e.g passing 100 will allow this debug to be rendered for 100 consecutive frames without clearing it from canvas)\n   */\n  static debugPoint(\n    key: string,\n    drawing: Drawing,\n    point: Vector,\n    props: { color: string; radius?: number },\n    frames?: number\n  ) {\n    Debug.limitDebugCalls(drawing, key, frames);\n\n    drawing.debugCalls[key].push({\n      debugFunction: Debug._debugPoint,\n      arguments: [drawing.canvas.context, point.clone(), props],\n    });\n  }\n\n  /* istanbul ignore next */\n  private static _debugPoint(\n    context: CanvasRenderingContext2D,\n    center: Vector,\n    props: { color: string; radius?: number }\n  ) {\n    context.fillStyle = props.color;\n    context.beginPath();\n    context.arc(\n      center.x,\n      center.y,\n      props.radius ? props.radius : 2,\n      0,\n      2 * Math.PI\n    );\n    context.fill();\n  }\n\n  /**\n   * Will render a line with green and red dots on start and end co-ordinates of line\n   *\n   * @param key A unique name for this debug\n   * @param drawing Drawing, on which this debug will render\n   * @param from Start Vector for this line\n   * @param to End Vector point for this line\n   * @param props Styling properties for debug\n   * @param frames Specifies for how many frames this debug will persist (e.g passing 100 will allow this debug to be rendered for 100 consecutive frames without clearing it from canvas)\n   */\n  static debugLine(\n    key: string,\n    drawing: Drawing,\n    from: Vector,\n    to: Vector,\n    props: { color: string; width?: number },\n    frames?: number\n  ) {\n    Debug.limitDebugCalls(drawing, key, frames);\n\n    drawing.debugCalls[key].push({\n      debugFunction: Debug._debugLine,\n      arguments: [drawing.canvas.context, from.clone(), to.clone(), props],\n    });\n  }\n\n  /* istanbul ignore next */\n  private static _debugLine(\n    context: CanvasRenderingContext2D,\n    from: Vector,\n    to: Vector,\n    props: { color: string; width?: number }\n  ) {\n    context.strokeStyle = props.color;\n    context.lineWidth = props.width ? props.width : 1;\n    context.beginPath();\n    context.moveTo(from.x, from.y);\n    context.lineTo(to.x, to.y);\n    context.stroke();\n\n    context.fillStyle = \"green\";\n    context.beginPath();\n    context.arc(from.x, from.y, 2, 0, 2 * Math.PI);\n    context.fill();\n\n    context.fillStyle = \"red\";\n    context.beginPath();\n    context.arc(to.x, to.y, 2, 0, 2 * Math.PI);\n    context.fill();\n  }\n\n  /**\n   * @hidden\n   *\n   * Starts debug render calls stored in debugCalls\n   */\n  static show(\n    debugCalls: Record<string, DebugCall[]>,\n    context: CanvasRenderingContext2D\n  ) {\n    for (let debug in debugCalls) {\n      for (let call of debugCalls[debug]) {\n        context.save();\n        call.debugFunction(...call.arguments);\n        context.restore();\n      }\n    }\n  }\n\n  // Used for persisting the debug calls on canvas (shifts array of debug calls to limit array size to frames)\n  /* istanbul ignore next */\n  private static limitDebugCalls(\n    drawing: Drawing,\n    key: string,\n    frames: number\n  ) {\n    if (\n      frames &&\n      drawing.debugCalls[key] &&\n      frames - 1 < drawing.debugCalls[key].length\n    ) {\n      drawing.debugCalls[key].shift();\n    } else {\n      (!drawing.debugCalls[key] || !frames) && (drawing.debugCalls[key] = []);\n    }\n  }\n}\n","import { Canvas, Debug, Node, Color } from \".\";\nimport { Vector } from \"../math/vector\";\nimport { Empty } from \"../view/empty\";\n\nexport interface DebugCall {\n  debugFunction: Function;\n  arguments: any[];\n  frames?: number;\n}\n\n/**\n * Stores all views which will be rendered by canvas\n */\nexport class Drawing {\n  // Scene-graph root node\n  private sceneGraph: Node;\n  /**@hidden */\n  debugCalls: Record<string, DebugCall[]>;\n\n  colorToNode: { [key: string]: Node };\n  pointers: any[] = [];\n\n  /**\n   *\n   * @param canvas The Canvas object\n   * @param globalUpdate A function that will be called per frame\n   */\n  constructor(public canvas: Canvas, public globalUpdate?: Function) {\n    let rootNode = new Empty(\"#Root\", Vector.Zero());\n    rootNode.context = this.canvas.context;\n    rootNode.drawing = this;\n    this.sceneGraph = rootNode;\n    this.debugCalls = {};\n\n    this.colorToNode = {};\n    this._registerEvents();\n  }\n\n  private getRelativePosition(ev: PointerEvent | WheelEvent | MouseEvent) {\n    const canvasOffset = this.canvas.canvasElement.getBoundingClientRect();\n    return new Vector(\n      ev.clientX - canvasOffset.left,\n      ev.clientY - canvasOffset.top\n    );\n  }\n\n  private updatePointer(ev: PointerEvent, position: Vector) {\n    let pointer = this.pointers.find((pntr) => pntr.id === ev.pointerId);\n    if (pointer) {\n      pointer.position = position;\n    }\n  }\n\n  private removePointer(ev: PointerEvent) {\n    this.pointers.splice(\n      this.pointers.findIndex((pointer) => pointer.id === ev.pointerId),\n      1\n    );\n  }\n\n  /* istanbul ignore next */\n  private _registerEvents(): void {\n    let currHitNode: Node, prevHitNode: Node;\n\n    this.canvas.canvasElement.onpointerdown = (ev: PointerEvent) => {\n      this.pointers.push({\n        id: ev.pointerId,\n        position: this.getRelativePosition(ev),\n      });\n\n      if (this.pointers.length === 1) {\n        currHitNode = this._getHitNode(this.pointers[0].position);\n        currHitNode &&\n          currHitNode.call(\"down\", [this.pointers[0].position.clone()]);\n      } else {\n        currHitNode = null;\n      }\n    };\n\n    this.canvas.canvasElement.onpointermove = (ev: PointerEvent) => {\n      const position = this.getRelativePosition(ev);\n      this.updatePointer(ev, position);\n\n      currHitNode && currHitNode.call(\"drag\", [position.clone()]);\n\n      if (ev.pointerType === \"mouse\" && !currHitNode) {\n        let hitNode = this._getHitNode(position);\n        if (hitNode !== prevHitNode) {\n          prevHitNode && prevHitNode.call(\"exit\", [position.clone()]);\n          hitNode && hitNode.call(\"enter\", [position.clone()]);\n        } else {\n          hitNode && !currHitNode && hitNode.call(\"over\", [position.clone()]);\n        }\n        prevHitNode = hitNode;\n      }\n    };\n\n    this.canvas.canvasElement.onpointerup = (ev: PointerEvent) => {\n      this.removePointer(ev);\n\n      currHitNode = null;\n\n      const position = this.getRelativePosition(ev);\n      let hitNode = this._getHitNode(position);\n      hitNode && hitNode.call(\"up\", [position.clone()]);\n    };\n\n    this.canvas.canvasElement.onpointerout = (ev) => {\n      this.removePointer(ev);\n\n      if (this.pointers.length === 0) {\n        currHitNode = null;\n      }\n      if (prevHitNode) {\n        const position = this.getRelativePosition(ev);\n        prevHitNode.call(\"exit\", [position.clone()]);\n        prevHitNode = null;\n      }\n    };\n\n    this.canvas.canvasElement.onclick = (ev) => {\n      const position = this.getRelativePosition(ev);\n      let hitNode = this._getHitNode(position);\n      hitNode && hitNode.call(\"click\", [position.clone()]);\n    };\n\n    this.canvas.canvasElement.oncontextmenu = (ev) => {\n      ev.preventDefault();\n\n      let hitNode = this._getHitNode(this.getRelativePosition(ev));\n      hitNode && hitNode.call(\"rightclick\");\n    };\n  }\n\n  /* istanbul ignore next */\n  private _getHitNode(position: Vector): Node {\n    return this.colorToNode[\n      Color.rgbToHex(\n        this.canvas.offContext.getImageData(position.x, position.y, 1, 1).data\n      )\n    ];\n  }\n\n  /** @hidden */\n  render() {\n    this.canvas.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    this.canvas.offContext.clearRect(\n      0,\n      0,\n      this.canvas.width,\n      this.canvas.height\n    );\n\n    this.sceneGraph.call(\"update\");\n\n    this.globalUpdate && this.globalUpdate();\n\n    this.sceneGraph.transform.childs.forEach((child) => {\n      child.updateWorldTransform();\n    });\n\n    this.sceneGraph.transform.childs.forEach((child) => {\n      child.node.render();\n    });\n\n    Debug.show(this.debugCalls, this.canvas.context);\n  }\n\n  /**\n   * Adds a view object to this drawing\n   *\n   * @param node A View object to be rendered\n   */\n  add(node: Node | Node[]): void {\n    if (node instanceof Node) {\n      node.parent = this.sceneGraph;\n      node.setContext(this.canvas.context, this.canvas.offContext);\n      node.setDrawing(this);\n      node.setHitColor();\n    } else {\n      node.forEach((cNode) => {\n        cNode.parent = this.sceneGraph;\n        cNode.setContext(this.canvas.context, this.canvas.offContext);\n        cNode.setDrawing(this);\n        cNode.setHitColor();\n      });\n    }\n  }\n\n  /**\n   * Removes a view object from this drawing\n   *\n   * @param nodeOrID A View object or its id\n   */\n  remove(nodeOrID: Node | string) {\n    if (nodeOrID instanceof Node) nodeOrID = nodeOrID.id;\n\n    let queue = [];\n    let currentNode;\n    queue.push(this.sceneGraph);\n\n    while ((currentNode = queue.shift())) {\n      if (currentNode.id == nodeOrID) {\n        currentNode.transform.parent.childs.splice(\n          currentNode.transform.parent.childs.indexOf(currentNode.transform),\n          1\n        );\n      } else {\n        currentNode.transform.childs.forEach((child) => {\n          queue.push(child.node);\n        });\n      }\n    }\n  }\n\n  /* istanbul ignore next */\n  private _debugSceneGraph(root: Node, indent: string): void {\n    console.log(indent + root.id + \"[\" + root.order + \"]\");\n\n    root.transform.childs.forEach((child) => {\n      this._debugSceneGraph(child.node, \" \" + indent);\n    });\n  }\n}\n","export * from \"./canvas\";\r\nexport * from \"./color\";\r\nexport * from \"./debug\";\r\nexport * from \"./drawing\";\r\nexport * from \"./event\";\r\nexport * from \"./node\";\r\n","import { Transform, Vector } from \"../math\";\nimport { Drawing } from \"./drawing\";\nimport { Event } from \"./event\";\nimport { Color } from \"./color\";\n\nexport abstract class Node implements Event {\n  drawing: Drawing;\n  context: CanvasRenderingContext2D;\n  offContext: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D;\n  transform: Transform;\n  registeredEvents: any;\n  order: number;\n  hitColor: string;\n\n  abstract _render(): void;\n  abstract _offRender(): void;\n  abstract getDimension(): Vector;\n\n  get zIndex(): number {\n    return this.order;\n  }\n  set zIndex(zIndex: number) {\n    this.order = zIndex;\n\n    if (this.parent) {\n      this.parent.transform.childs.sort((a, b) => {\n        return a.node.order - b.node.order;\n      });\n    }\n  }\n\n  get parent(): Node {\n    return this.transform.parent.node;\n  }\n  set parent(newParent: Node) {\n    this.transform.parent = newParent.transform;\n  }\n\n  get childs(): Node[] {\n    return this.transform.childs.map((child) => {\n      return child.node;\n    });\n  }\n\n  get position(): Vector {\n    return this.transform.position;\n  }\n  set position(position: Vector) {\n    this.transform.position = position;\n  }\n  get absolutePosition(): Vector {\n    return this.transform.absolutePosition;\n  }\n\n  get rotation(): number {\n    return this.transform.rotation;\n  }\n  set rotation(degrees: number) {\n    this.transform.rotation = degrees;\n  }\n\n  get localRotation(): number {\n    return this.transform.localRotation;\n  }\n  set localRotation(degrees: number) {\n    this.transform.localRotation = degrees;\n  }\n\n  get scale(): Vector {\n    return this.transform.scale;\n  }\n  set scale(scale: Vector) {\n    this.transform.scale = scale;\n  }\n\n  constructor(public id: string, position: Vector, controlPoints: Vector[]) {\n    this.transform = new Transform(\n      position,\n      0,\n      0,\n      Vector.Unit(),\n      controlPoints,\n      this\n    );\n    this.registeredEvents = {};\n    this.order = 0;\n  }\n\n  setHitColor() {\n    // Set unique color for hit detection in offscreen canvas\n    let color: string = Color.Random();\n    while (this.drawing.colorToNode[color]) {\n      color = Color.Random();\n    }\n\n    this.hitColor = color;\n    this.drawing.colorToNode[color] = this;\n\n    this.transform.childs.forEach((child) => {\n      child.node.setHitColor();\n    });\n  }\n\n  on(eventKey: string, callback: Function): void {\n    this.registeredEvents[eventKey] = callback;\n  }\n\n  render(): void {\n    this.context.save();\n    this._render();\n    this.context.restore();\n    this.offRender();\n\n    for (var child of this.transform.childs) {\n      child.node.render();\n    }\n  }\n\n  offRender(): void {\n    this.offContext.save();\n    this._offRender();\n    this.offContext.restore();\n  }\n\n  call(method: string, args?: any[]) {\n    if (this.registeredEvents[method]) {\n      if (args) {\n        this.registeredEvents[method](this, ...args);\n      } else {\n        this.registeredEvents[method](this);\n      }\n    }\n\n    for (var child of this.transform.childs) {\n      child.node.call(method, args);\n    }\n  }\n\n  setContext(\n    context: CanvasRenderingContext2D,\n    offContext: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D\n  ) {\n    this.context = context;\n    this.offContext = offContext;\n    this.transform.childs.forEach((child) => {\n      child.node.setContext(context, offContext);\n    });\n  }\n\n  setDrawing(drawing: Drawing) {\n    this.drawing = drawing;\n    this.transform.childs.forEach((child) => {\n      child.node.setDrawing(drawing);\n    });\n  }\n\n  dispose(): void {\n    this.drawing.remove(this.id);\n  }\n}\n","export class Dimension {\r\n  constructor(public width: number, public height: number) {}\r\n\r\n  max() {\r\n    return Math.max(this.width, this.height);\r\n  }\r\n}\r\n","export * from \"./dimension\";\r\nexport * from \"./matrix\";\r\nexport * from \"./transform\";\r\nexport * from \"./vector\";\r\n","/**\n * A 3x3 Matrix\n */\nexport class Matrix {\n  value: number[][];\n\n  constructor(value: number[][]) {\n    this.value = value;\n  }\n\n  /* istanbul ignore next */\n  private _multiply(another: Matrix | number[][]): number[][] {\n    let result;\n    if (another instanceof Matrix) {\n      result = [...Array(this.value.length)].map(() =>\n        Array(another.value[0].length)\n      );\n\n      for (let i = 0; i < this.value.length; i++) {\n        for (let j = 0; j < another.value[0].length; j++) {\n          let sum = 0;\n          for (let k = 0; k < this.value[0].length; k++) {\n            sum += this.value[i][k] * another.value[k][j];\n          }\n          result[i][j] = sum;\n        }\n      }\n    } else {\n      result = [...Array(this.value.length)].map(() =>\n        Array(another[0].length)\n      );\n\n      for (let i = 0; i < this.value.length; i++) {\n        for (let j = 0; j < another[0].length; j++) {\n          let sum = 0;\n          for (let k = 0; k < this.value[0].length; k++) {\n            sum += this.value[i][k] * another[k][j];\n          }\n          result[i][j] = sum;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  multiply(another: Matrix | number[][]): Matrix {\n    return new Matrix(this._multiply(another));\n  }\n\n  multiplyInPlace(another: Matrix | number[][]): Matrix {\n    this.value = this._multiply(another);\n    return this;\n  }\n\n  clone() {\n    return new Matrix([\n      [this.value[0][0], this.value[0][1], this.value[0][2]],\n      [this.value[1][0], this.value[1][1], this.value[1][2]],\n      [this.value[2][0], this.value[2][1], this.value[2][2]],\n    ]);\n  }\n\n  /**\n   * Decomposes the rotation component from matrix to get absolute rotation for a child transform\n   */\n  getRotation(): number {\n    return Math.atan2(this.value[0][1], this.value[0][0]) * (180 / Math.PI);\n  }\n\n  static Identity() {\n    return new Matrix([\n      [1, 0, 0],\n      [0, 1, 0],\n      [0, 0, 1],\n    ]);\n  }\n\n  static Zero() {\n    return new Matrix([\n      [0, 0, 0],\n      [0, 0, 0],\n      [0, 0, 0],\n    ]);\n  }\n\n  static Multiply(matrix1: number[][], matrix2: number[][]) {\n    let result = [...Array(matrix1.length)].map(() => Array(matrix2[0].length));\n\n    for (let i = 0; i < matrix1.length; i++) {\n      for (let j = 0; j < matrix2[0].length; j++) {\n        let sum = 0;\n        for (let k = 0; k < matrix1[0].length; k++) {\n          sum += matrix1[i][k] * matrix2[k][j];\n        }\n        result[i][j] = sum;\n      }\n    }\n\n    return result;\n  }\n}\n","import { Matrix, Vector } from \"./index\";\nimport { Constant } from \"../common/constants\";\nimport { Node } from \"../core/node\";\n\n// Stores a node's transform (position, rotation, scale)\nexport class Transform {\n  // reference control points to apply transform to\n  refControlPoints: Vector[];\n  // transformed control points\n  controlPoints: Vector[];\n  localTrasform: Matrix;\n  worldTransform: Matrix;\n  childs: Transform[];\n  private _parent: Transform;\n  private _position: Vector;\n  private _localRotation: number;\n  private _rotation: number;\n  private _scale: Vector;\n\n  get parent(): Transform {\n    return this._parent;\n  }\n  set parent(newParent: Transform) {\n    if (this._parent) {\n      const index = this._parent.childs.indexOf(this);\n      if (index > -1) {\n        this._parent.childs.splice(index, 1);\n      }\n    }\n    newParent && newParent.childs.push(this);\n    this._parent = newParent;\n\n    if (this._parent) {\n      this._parent.childs.sort((a, b) => {\n        return a.node.order - b.node.order;\n      });\n    }\n  }\n\n  get position(): Vector {\n    return this._position;\n  }\n  set position(newPosition: Vector) {\n    this._position = newPosition;\n  }\n\n  get absolutePosition(): Vector {\n    return Vector.Zero().transform(this.worldTransform);\n  }\n\n  get rotation(): number {\n    return this._rotation;\n  }\n  set rotation(degrees: number) {\n    this._rotation = degrees % 360;\n  }\n\n  get localRotation(): number {\n    return this._localRotation;\n  }\n  set localRotation(newRotation: number) {\n    this._localRotation = newRotation % 360;\n  }\n\n  get scale(): Vector {\n    return this._scale;\n  }\n  set scale(newScale: Vector) {\n    this._scale = newScale;\n  }\n\n  constructor(\n    position: Vector,\n    localRotation: number,\n    rotation: number,\n    scale: Vector,\n    controlPoints: Vector[],\n    public node: Node\n  ) {\n    this._position = position;\n    this._localRotation = localRotation;\n    this._rotation = rotation;\n    this._scale = scale;\n    this._parent = null;\n    this.childs = [];\n    this.localTrasform = Matrix.Identity();\n    this.worldTransform = Matrix.Identity();\n    this.refControlPoints = this.relativeControlPoints(controlPoints);\n    this.controlPoints = [...controlPoints];\n  }\n\n  /* istanbul ignore next */\n  private relativeControlPoints(controlPoints: Vector[]): Vector[] {\n    let result: Vector[] = [];\n    controlPoints.forEach((controlPoint) => {\n      result.push(controlPoint.subtract(this.position));\n    });\n    return result;\n  }\n\n  // Transforms each control point using this node's worldTransform\n  /* istanbul ignore next */\n  private applyTransform() {\n    this.refControlPoints.forEach((controlPoint, index) => {\n      this.controlPoints[index] = controlPoint.transform(this.worldTransform);\n    });\n  }\n\n  /* istanbul ignore next */\n  private _updateWorldTransform(parentWorldTransform?: Matrix) {\n    // Set translation\n    this.localTrasform.value = [\n      [1, 0, 0],\n      [0, 1, 0],\n      [this.position.x, this.position.y, 1],\n    ];\n\n    let cos;\n    let sin;\n    // Transform rotation\n    if (this.parent.node.id != \"#Root\") {\n      cos = Math.cos(this.rotation * Constant.TAU);\n      sin = Math.sin(this.rotation * Constant.TAU);\n\n      this.localTrasform = new Matrix([\n        [1, 0, 0],\n        [0, 1, 0],\n        [this.position.x, this.position.y, 1],\n      ])\n        .multiply([\n          [cos, sin, 0],\n          [-sin, cos, 0],\n          [0, 0, 1],\n        ])\n        .multiply([\n          [1, 0, 0],\n          [0, 1, 0],\n          [-this.position.x, -this.position.y, 1],\n        ])\n        .multiply(this.localTrasform);\n    }\n\n    // Transform localRotation\n    cos = Math.cos(this.localRotation * Constant.TAU);\n    sin = Math.sin(this.localRotation * Constant.TAU);\n    this.localTrasform = new Matrix([\n      [cos, sin, 0],\n      [-sin, cos, 0],\n      [0, 0, 1],\n    ]).multiply(this.localTrasform);\n\n    // Transform scale\n    this.localTrasform = new Matrix([\n      [this.scale.x, 0, 0],\n      [0, this.scale.y, 0],\n      [0, 0, 1],\n    ]).multiply(this.localTrasform);\n\n    if (parentWorldTransform) {\n      this.worldTransform = this.localTrasform.multiply(parentWorldTransform);\n    } else {\n      this.worldTransform = this.localTrasform.clone();\n    }\n\n    this.childs.forEach((child) => {\n      child.updateWorldTransform(this.worldTransform);\n    });\n\n    this.applyTransform();\n  }\n\n  // Updates this node's worldTransform using parent's worldTransform if any\n  updateWorldTransform(parentWorldTransform?: Matrix) {\n    this._updateWorldTransform(parentWorldTransform);\n  }\n}\n","import { Canvas } from \"../core/canvas\";\nimport { Constant } from \"../common/constants\";\nimport { Matrix } from \"../math/matrix\";\n\n/**\n * Stores 2D Vector\n */\nexport class Vector {\n  tmpX: number;\n  tmpY: number;\n\n  constructor(public x: number, public y: number) {}\n\n  toString() {\n    return \"[\" + this.x.toFixed(3) + \", \" + this.y.toFixed(3) + \"]\";\n  }\n\n  add(x: number, y: number): Vector;\n  add(value: number): Vector;\n  add(vector: Vector): Vector;\n  add(arg1: number | Vector, arg2?: number): Vector {\n    // Params : (vector) or (x, y)\n    if (arg1 instanceof Vector) {\n      return new Vector(this.x + arg1.x, this.y + arg1.y);\n    } else if (typeof arg2 === \"undefined\") {\n      return new Vector(this.x + arg1, this.y + arg1);\n    } else {\n      return new Vector(this.x + arg1, this.y + arg2);\n    }\n  }\n\n  addInPlace(x: number, y: number): Vector;\n  addInPlace(value: number): Vector;\n  addInPlace(vector: Vector): Vector;\n  addInPlace(arg1: number | Vector, arg2?: number): Vector {\n    // Params : (vector) or (x, y)\n    if (arg1 instanceof Vector) {\n      this.x += arg1.x;\n      this.y += arg1.y;\n    } else if (typeof arg2 === \"undefined\") {\n      this.x += arg1;\n      this.y += arg1;\n    } else {\n      this.x += arg1;\n      this.y += arg2;\n    }\n    return this;\n  }\n\n  multiply(x: number, y: number): Vector;\n  multiply(value: number): Vector;\n  multiply(vector: Vector): Vector;\n  multiply(arg1: number | Vector, arg2?: number): Vector {\n    // Params : (vector) or (x, y)\n    if (arg1 instanceof Vector) {\n      return new Vector(this.x * arg1.x, this.y * arg1.y);\n    } else if (typeof arg2 === \"undefined\") {\n      return new Vector(this.x * arg1, this.y * arg1);\n    } else {\n      return new Vector(this.x * arg1, this.y * arg2);\n    }\n  }\n\n  multiplyInPlace(x: number, y: number): Vector;\n  multiplyInPlace(value: number): Vector;\n  multiplyInPlace(vector: Vector): Vector;\n  multiplyInPlace(arg1: number | Vector, arg2?: number): Vector {\n    // Params : (vector) or (x, y)\n    if (arg1 instanceof Vector) {\n      this.x *= arg1.x;\n      this.y *= arg1.y;\n    } else if (typeof arg2 === \"undefined\") {\n      this.x *= arg1;\n      this.y *= arg1;\n    } else {\n      this.x *= arg1;\n      this.y *= arg2;\n    }\n    return this;\n  }\n\n  subtract(x: number, y: number): Vector;\n  subtract(value: number): Vector;\n  subtract(vector: Vector): Vector;\n  subtract(arg1: number | Vector, arg2?: number): Vector {\n    // Params : (vector) or (x, y)\n    if (arg1 instanceof Vector) {\n      return new Vector(this.x - arg1.x, this.y - arg1.y);\n    } else if (typeof arg2 === \"undefined\") {\n      return new Vector(this.x - arg1, this.y - arg1);\n    } else {\n      return new Vector(this.x - arg1, this.y - arg2);\n    }\n  }\n\n  subtractInPlace(x: number, y: number): Vector;\n  subtractInPlace(value: number): Vector;\n  subtractInPlace(vector: Vector): Vector;\n  subtractInPlace(arg1: number | Vector, arg2?: number): Vector {\n    // Params : (vector) or (x, y)\n    if (arg1 instanceof Vector) {\n      this.x -= arg1.x;\n      this.y -= arg1.y;\n    } else if (typeof arg2 === \"undefined\") {\n      this.x -= arg1;\n      this.y -= arg1;\n    } else {\n      this.x -= arg1;\n      this.y -= arg2;\n    }\n\n    return this;\n  }\n\n  rotate(pivot: Vector, degrees: number): Vector {\n    degrees = degrees * Constant.TAU;\n    let cosT = Math.cos(degrees);\n    let sinT = Math.sin(degrees);\n    return new Vector(\n      cosT * (this.x - pivot.x) - sinT * (this.y - pivot.y) + pivot.x,\n      sinT * (this.x - pivot.x) + cosT * (this.y - pivot.y) + pivot.y\n    );\n  }\n\n  rotateInPlace(pivot: Vector, degrees: number): Vector {\n    degrees = degrees * Constant.TAU;\n    let cosT = Math.cos(degrees);\n    let sinT = Math.sin(degrees);\n    this.tmpX = cosT * (this.x - pivot.x) - sinT * (this.y - pivot.y) + pivot.x;\n    this.tmpY = sinT * (this.x - pivot.x) + cosT * (this.y - pivot.y) + pivot.y;\n    this.x = this.tmpX;\n    this.y = this.tmpY;\n    return this;\n  }\n\n  transform(matrix: Matrix) {\n    let result = Matrix.Multiply([[this.x, this.y, 1]], matrix.value);\n    return new Vector(result[0][0], result[0][1]);\n  }\n\n  transformInPlace(matrix: Matrix): Vector {\n    let result = Matrix.Multiply([[this.x, this.y, 1]], matrix.value);\n    this.x = result[0][0];\n    this.y = result[0][1];\n    return this;\n  }\n\n  max() {\n    return Math.max(this.x, this.y);\n  }\n\n  static Midpoint(vector1: Vector, vector2: Vector): Vector {\n    return new Vector((vector1.x + vector2.x) / 2, (vector1.y + vector2.y) / 2);\n  }\n\n  static Distance(vector1: Vector, vector2: Vector): number {\n    return Math.sqrt(\n      Math.pow(vector2.x - vector1.x, 2) + Math.pow(vector2.y - vector1.y, 2)\n    );\n  }\n\n  static Zero(): Vector {\n    return new Vector(0, 0);\n  }\n\n  static Unit(): Vector {\n    return new Vector(1, 1);\n  }\n\n  static Bounds(vectors: Vector[]): Vector[] {\n    let minVec = new Vector(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\n    let maxVec = new Vector(Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);\n\n    vectors.forEach((vector) => {\n      if (vector.x < minVec.x) minVec.x = vector.x;\n      if (vector.y < minVec.y) minVec.y = vector.y;\n      if (vector.x > maxVec.x) maxVec.x = vector.x;\n      if (vector.y > maxVec.y) maxVec.y = vector.y;\n    });\n    return [minVec, maxVec];\n  }\n\n  static Average(vectors: Vector[]): Vector {\n    let sumX = 0;\n    let sumY = 0;\n    vectors.forEach((vector) => {\n      sumX += vector.x;\n      sumY += vector.y;\n    });\n    return new Vector(sumX / vectors.length, sumY / vectors.length);\n  }\n\n  static Random(canvas: Canvas): Vector;\n  static Random(minX: number, maxX: number, minY: number, maxY: number): Vector;\n  static Random(\n    minXOrCanvas: number | Canvas,\n    maxX?: number,\n    minY?: number,\n    maxY?: number\n  ): Vector {\n    if (minXOrCanvas instanceof Canvas) {\n      return new Vector(\n        Math.random() * minXOrCanvas.width,\n        Math.random() * minXOrCanvas.height\n      );\n    } else {\n      return new Vector(\n        Math.random() * (maxX - minXOrCanvas) + minXOrCanvas,\n        Math.random() * (maxY - minY) + minY\n      );\n    }\n  }\n\n  static Lerp(start: Vector, end: Vector, amount: number): Vector {\n    return new Vector(\n      start.x + (end.x - start.x) * amount,\n      start.y + (end.y - start.y) * amount\n    );\n  }\n\n  clone(): Vector {\n    return new Vector(this.x, this.y);\n  }\n}\n","export * from \"./common\";\r\nexport * as View from \"./view\";\r\nexport * from \"./core\";\r\nexport * from \"./math\";\r\n","import { Vector } from \"../math/vector\";\nimport { LinearGradient, RadialGradient } from \"./index\";\nimport { Node } from \"../core/node\";\n\nexport interface EllipseOptions {\n  outline?: boolean;\n  fill?: boolean;\n  outlineColor?: string | LinearGradient | RadialGradient;\n  fillColor?: string | LinearGradient | RadialGradient;\n  outlineWidth?: number;\n  outlineDashSegments?: number[];\n  shadowColor?: string;\n  shadowOffset?: Vector;\n  staticShadow?: boolean;\n  shadowBlur?: number;\n}\n\nexport class Ellipse extends Node {\n  constructor(\n    id: string,\n    position: Vector,\n    public minor: number,\n    public major: number,\n    public props: EllipseOptions = {}\n  ) {\n    super(id, position, [\n      position.subtract(0, minor),\n      position.add(major, 0),\n      position.add(0, minor),\n      position.subtract(major, 0),\n    ]);\n\n    if (\n      this.props.outlineColor &&\n      typeof this.props.outlineColor !== \"string\"\n    ) {\n      this.props.outlineColor.node = this;\n    }\n    if (this.props.fillColor && typeof this.props.fillColor !== \"string\") {\n      this.props.fillColor.node = this;\n    }\n  }\n\n  /* istanbul ignore next */\n  _render(): void {\n    if (this.props) {\n      this.props.outlineColor &&\n        (this.context.strokeStyle =\n          typeof this.props.outlineColor == \"string\"\n            ? this.props.outlineColor\n            : this.props.outlineColor.create(this.context));\n      this.props.fillColor &&\n        (this.context.fillStyle =\n          typeof this.props.fillColor == \"string\"\n            ? this.props.fillColor\n            : this.props.fillColor.create(this.context));\n      this.props.outlineWidth &&\n        (this.context.lineWidth = this.props.outlineWidth);\n      this.props.outlineDashSegments &&\n        this.context.setLineDash(this.props.outlineDashSegments);\n      this.props.shadowColor &&\n        (this.context.shadowColor = this.props.shadowColor);\n      this.props.shadowBlur &&\n        (this.context.shadowBlur = this.props.shadowBlur);\n      if (this.props.shadowOffset) {\n        if (!this.props.staticShadow) {\n          let shadowOffset = this.props.shadowOffset\n            .transform(this.transform.worldTransform)\n            .subtract(this.absolutePosition);\n          this.context.shadowOffsetX = shadowOffset.x;\n          this.context.shadowOffsetY = shadowOffset.y;\n        } else {\n          this.context.shadowOffsetX = this.props.shadowOffset.x;\n          this.context.shadowOffsetY = this.props.shadowOffset.y;\n        }\n      }\n    }\n\n    let position = this.absolutePosition;\n    this.context.beginPath();\n    if (this.minor == this.major) {\n      this.context.arc(position.x, position.y, this.minor, 0, 2 * Math.PI);\n    } else {\n      this.context.ellipse(\n        position.x,\n        position.y,\n        this.major,\n        this.minor,\n        Math.atan2(\n          this.transform.controlPoints[1].y - position.y,\n          this.transform.controlPoints[1].x - position.x\n        ),\n        0,\n        2 * Math.PI\n      );\n    }\n    if (this.props.fill) {\n      this.context.fill();\n    }\n    if (this.props.outline || !this.props.fill) {\n      this.context.stroke();\n    }\n  }\n\n  /* istanbul ignore next */\n  _offRender(): void {\n    this.props.outlineWidth &&\n      (this.offContext.lineWidth = this.props.outlineWidth);\n    this.offContext.strokeStyle = this.hitColor;\n    this.offContext.fillStyle = this.hitColor;\n\n    let position = this.absolutePosition;\n    this.offContext.beginPath();\n    if (this.minor == this.major) {\n      this.offContext.arc(position.x, position.y, this.minor, 0, 2 * Math.PI);\n    } else {\n      this.offContext.ellipse(\n        position.x,\n        position.y,\n        this.major,\n        this.minor,\n        Math.atan2(\n          this.transform.controlPoints[1].y - position.y,\n          this.transform.controlPoints[1].x - position.x\n        ),\n        0,\n        2 * Math.PI\n      );\n    }\n    if (this.props.fill) {\n      this.offContext.fill();\n    }\n    if (this.props.outline || !this.props.fill) {\n      this.offContext.stroke();\n    }\n  }\n\n  getDimension(): Vector {\n    return new Vector(\n      Vector.Distance(\n        this.transform.controlPoints[1],\n        this.transform.controlPoints[3]\n      ),\n      Vector.Distance(\n        this.transform.controlPoints[0],\n        this.transform.controlPoints[2]\n      )\n    );\n  }\n}\n","import { Vector } from \"../math/vector\";\nimport { Node } from \"../core/node\";\n\nexport class Empty extends Node {\n  constructor(id: string, position: Vector) {\n    super(id, position, []);\n  }\n\n  _render(): void {\n    /**/\n  }\n  _offRender(): void {\n    /**/\n  }\n\n  getDimension(): Vector {\n    return Vector.Zero();\n  }\n}\n","import { Vector } from \"../math/vector\";\nimport { Node } from \"../core/node\";\n\nexport interface ImageOptions {\n  shadowColor?: string;\n  shadowOffset?: Vector;\n  staticShadow?: boolean;\n  shadowBlur?: number;\n}\n\nexport class Image extends Node {\n  _source: HTMLImageElement;\n\n  constructor(\n    id: string,\n    position: Vector,\n    source: string | HTMLImageElement,\n    public width: number,\n    public height: number,\n    public props: ImageOptions = {}\n  ) {\n    super(id, position, []);\n\n    if (typeof source == \"string\") {\n      this._source = new window.Image();\n      this._source.src = source;\n    } else {\n      this._source = source;\n    }\n    this._source.crossOrigin = \"Anonymous\";\n  }\n\n  /* istanbul ignore next */\n  _render(): void {\n    if (this.props) {\n      this.props.shadowColor &&\n        (this.context.shadowColor = this.props.shadowColor);\n      this.props.shadowBlur &&\n        (this.context.shadowBlur = this.props.shadowBlur);\n      if (this.props.shadowOffset) {\n        if (!this.props.staticShadow) {\n          let shadowOffset = this.props.shadowOffset\n            .transform(this.transform.worldTransform)\n            .subtract(this.absolutePosition);\n          this.context.shadowOffsetX = shadowOffset.x;\n          this.context.shadowOffsetY = shadowOffset.y;\n        } else {\n          this.context.shadowOffsetX = this.props.shadowOffset.x;\n          this.context.shadowOffsetY = this.props.shadowOffset.y;\n        }\n      }\n    }\n\n    // Rotate image using worldTransform's rotation component\n    this.context.translate(this.absolutePosition.x, this.absolutePosition.y);\n    this.context.rotate(\n      this.transform.worldTransform.getRotation() * (Math.PI / 180)\n    );\n    this.context.translate(-this.absolutePosition.x, -this.absolutePosition.y);\n\n    let topLeft = this.absolutePosition.subtract(\n      (this.width * this.transform.scale.x) / 2,\n      (this.height * this.transform.scale.y) / 2\n    );\n    this.context.drawImage(\n      this._source,\n      topLeft.x,\n      topLeft.y,\n      this.width * this.transform.scale.x,\n      this.height * this.transform.scale.y\n    );\n  }\n\n  /* istanbul ignore next */\n  _offRender(): void {\n    this.offContext.fillStyle = this.hitColor;\n\n    // Rotate bounding-rectangle using worldTransform's rotation component\n    this.offContext.translate(this.absolutePosition.x, this.absolutePosition.y);\n    this.offContext.rotate(\n      this.transform.worldTransform.getRotation() * (Math.PI / 180)\n    );\n    this.offContext.translate(\n      -this.absolutePosition.x,\n      -this.absolutePosition.y\n    );\n\n    let topLeft = this.absolutePosition.subtract(\n      (this.width * this.transform.scale.x) / 2,\n      (this.height * this.transform.scale.y) / 2\n    );\n    this.offContext.fillRect(\n      topLeft.x,\n      topLeft.y,\n      this.width * this.transform.scale.x,\n      this.height * this.transform.scale.y\n    );\n  }\n\n  getDimension(): Vector {\n    return new Vector(this.width, this.height);\n  }\n}\n","export * from \"./ellipse\";\r\nexport * from \"./empty\";\r\nexport * from \"./image\";\r\nexport * from \"./line\";\r\nexport * from \"./polygon\";\r\nexport * from \"./rectangle\";\r\nexport * from \"./text\";\r\nexport * from \"./linear-gradient\";\r\nexport * from \"./radial-gradient\";\r\n","import { Vector } from \"../math/vector\";\nimport { LinearGradient, RadialGradient } from \".\";\nimport { Node } from \"../core/node\";\n\nexport interface LineOptions {\n  color?: string | LinearGradient | RadialGradient;\n  lineWidth?: number;\n  lineCap?: CanvasLineCap;\n  lineDashSegments?: number[];\n  shadowColor?: string;\n  shadowOffset?: Vector;\n  staticShadow?: boolean;\n  shadowBlur?: number;\n}\n\nexport class Line extends Node {\n  get from(): Vector {\n    if (this._from instanceof Node) return this._from.absolutePosition;\n    else return this.transform.controlPoints[0];\n  }\n  get to(): Vector {\n    if (this._to instanceof Node) return this._to.absolutePosition;\n    else return this.transform.controlPoints[1];\n  }\n\n  constructor(\n    id: string,\n    public _from: Vector | Node,\n    public _to: Vector | Node,\n    pivot?: number,\n    public props: LineOptions = {}\n  ) {\n    super(\n      id,\n      _from instanceof Vector && _to instanceof Vector\n        ? pivot\n          ? _from.add((_to.x - _from.x) * pivot, (_to.y - _from.y) * pivot)\n          : _from.clone()\n        : Vector.Zero(),\n      _from instanceof Vector && _to instanceof Vector ? [_from, _to] : []\n    );\n\n    if (this.props.color && typeof this.props.color !== \"string\") {\n      this.props.color.node = this;\n    }\n  }\n\n  /* istanbul ignore next */\n  _render(): void {\n    if (this.props) {\n      this.props.color &&\n        (this.context.strokeStyle =\n          typeof this.props.color == \"string\"\n            ? this.props.color\n            : this.props.color.create(this.context));\n      this.props.lineWidth && (this.context.lineWidth = this.props.lineWidth);\n      this.props.lineCap && (this.context.lineCap = this.props.lineCap);\n      this.props.lineDashSegments &&\n        this.context.setLineDash(this.props.lineDashSegments);\n      this.props.shadowColor &&\n        (this.context.shadowColor = this.props.shadowColor);\n      this.props.shadowBlur &&\n        (this.context.shadowBlur = this.props.shadowBlur);\n      if (this.props.shadowOffset) {\n        if (!this.props.staticShadow) {\n          let shadowOffset = this.props.shadowOffset\n            .transform(this.transform.worldTransform)\n            .subtract(this.absolutePosition);\n          this.context.shadowOffsetX = shadowOffset.x;\n          this.context.shadowOffsetY = shadowOffset.y;\n        } else {\n          this.context.shadowOffsetX = this.props.shadowOffset.x;\n          this.context.shadowOffsetY = this.props.shadowOffset.y;\n        }\n      }\n    }\n\n    this.context.beginPath();\n    this.context.moveTo(this.from.x, this.from.y);\n    this.context.lineTo(this.to.x, this.to.y);\n    this.context.stroke();\n  }\n\n  /* istanbul ignore next */\n  _offRender(): void {\n    this.props.lineWidth && (this.offContext.lineWidth = this.props.lineWidth);\n    this.offContext.strokeStyle = this.hitColor;\n\n    this.offContext.beginPath();\n    this.offContext.moveTo(this.from.x, this.from.y);\n    this.offContext.lineTo(this.to.x, this.to.y);\n    this.offContext.stroke();\n  }\n\n  getDimension(): Vector {\n    return new Vector(\n      Vector.Distance(\n        this.transform.controlPoints[0],\n        this.transform.controlPoints[1]\n      ),\n      0\n    );\n  }\n}\n","import { Constant, Handle } from \"../common\";\nimport { Node } from \"../core/node\";\nimport { Vector } from \"../math/vector\";\n\nexport class LinearGradient {\n  node: Node;\n\n  constructor(\n    public offset: Vector,\n    public degrees: number,\n    public length: number | Handle,\n    public colors: string[],\n    public weights: number[]\n  ) {}\n\n  create(context: CanvasRenderingContext2D): CanvasGradient {\n    let gradient: CanvasGradient,\n      from,\n      to,\n      length,\n      delta = new Vector(0, 0);\n\n    length =\n      this.length == Handle.AUTO ? this.node.getDimension().max() : this.length;\n    delta.x = (length / 2) * Math.cos(this.degrees * Constant.TAU);\n    delta.y = (length / 2) * Math.sin(this.degrees * Constant.TAU);\n\n    from = this.offset\n      .subtract(delta)\n      .transform(this.node.transform.worldTransform);\n    to = this.offset.add(delta).transform(this.node.transform.worldTransform);\n\n    gradient = context.createLinearGradient(from.x, from.y, to.x, to.y);\n    this.colors.forEach((color, index) => {\n      gradient.addColorStop(this.weights[index], color);\n    });\n    return gradient;\n  }\n}\n","import { Vector } from \"../math/vector\";\nimport { LinearGradient, RadialGradient } from \"./index\";\nimport { Node } from \"../core/node\";\nimport { Handle } from \"../common/enums\";\n\nexport interface PolygonOptions {\n  outline?: boolean;\n  fill?: boolean;\n  outlineColor?: string | LinearGradient | RadialGradient;\n  fillColor?: string | LinearGradient | RadialGradient;\n  outlineWidth?: number;\n  outlineDashSegments?: number[];\n  shadowColor?: string;\n  shadowOffset?: Vector;\n  staticShadow?: boolean;\n  shadowBlur?: number;\n}\n\nexport class Polygon extends Node {\n  constructor(\n    id: string,\n    vertices: Vector[],\n    center: Vector | Handle,\n    public props: PolygonOptions = {}\n  ) {\n    super(\n      id,\n      center instanceof Vector ? center : Vector.Average(vertices),\n      vertices\n    );\n\n    if (\n      this.props.outlineColor &&\n      typeof this.props.outlineColor !== \"string\"\n    ) {\n      this.props.outlineColor.node = this;\n    }\n    if (this.props.fillColor && typeof this.props.fillColor !== \"string\") {\n      this.props.fillColor.node = this;\n    }\n  }\n\n  /* istanbul ignore next */\n  _render(): void {\n    if (this.props) {\n      this.props.outlineColor &&\n        (this.context.strokeStyle =\n          typeof this.props.outlineColor == \"string\"\n            ? this.props.outlineColor\n            : this.props.outlineColor.create(this.context));\n      this.props.fillColor &&\n        (this.context.fillStyle =\n          typeof this.props.fillColor == \"string\"\n            ? this.props.fillColor\n            : this.props.fillColor.create(this.context));\n      this.props.outlineWidth &&\n        (this.context.lineWidth = this.props.outlineWidth);\n      this.props.outlineDashSegments &&\n        this.context.setLineDash(this.props.outlineDashSegments);\n      this.props.shadowColor &&\n        (this.context.shadowColor = this.props.shadowColor);\n      this.props.shadowBlur &&\n        (this.context.shadowBlur = this.props.shadowBlur);\n      if (this.props.shadowOffset) {\n        if (!this.props.staticShadow) {\n          let shadowOffset = this.props.shadowOffset\n            .transform(this.transform.worldTransform)\n            .subtract(this.absolutePosition);\n          this.context.shadowOffsetX = shadowOffset.x;\n          this.context.shadowOffsetY = shadowOffset.y;\n        } else {\n          this.context.shadowOffsetX = this.props.shadowOffset.x;\n          this.context.shadowOffsetY = this.props.shadowOffset.y;\n        }\n      }\n    }\n\n    this.context.beginPath();\n    this.context.moveTo(\n      this.transform.controlPoints[0].x,\n      this.transform.controlPoints[0].y\n    );\n    for (let index = 1; index < this.transform.controlPoints.length; index++) {\n      this.context.lineTo(\n        this.transform.controlPoints[index].x,\n        this.transform.controlPoints[index].y\n      );\n    }\n    this.context.closePath();\n\n    if (this.props.fill) {\n      this.context.fill();\n    }\n    if (this.props.outline || !this.props.fill) {\n      this.context.stroke();\n    }\n  }\n\n  /* istanbul ignore next */\n  _offRender(): void {\n    this.props.outlineWidth &&\n      (this.offContext.lineWidth = this.props.outlineWidth);\n    this.offContext.strokeStyle = this.hitColor;\n    this.offContext.fillStyle = this.hitColor;\n\n    this.offContext.beginPath();\n    this.offContext.moveTo(\n      this.transform.controlPoints[0].x,\n      this.transform.controlPoints[0].y\n    );\n    for (let index = 1; index < this.transform.controlPoints.length; index++) {\n      this.offContext.lineTo(\n        this.transform.controlPoints[index].x,\n        this.transform.controlPoints[index].y\n      );\n    }\n    this.offContext.closePath();\n\n    if (this.props.fill) {\n      this.offContext.fill();\n    }\n    if (this.props.outline || !this.props.fill) {\n      this.offContext.stroke();\n    }\n  }\n\n  getDimension(): Vector {\n    let bounds = Vector.Bounds(this.transform.controlPoints);\n\n    return new Vector(\n      Math.abs(bounds[0].x - bounds[1].x),\n      Math.abs(bounds[0].y - bounds[1].y)\n    );\n  }\n}\n","import { Vector } from \"../math/vector\";\nimport { Handle } from \"../common/enums\";\nimport { Node } from \"../core/node\";\n\nexport class RadialGradient {\n  node: Node;\n\n  constructor(\n    public fromOffset: Vector,\n    public fromRadius: number | Handle,\n    public toOffset: Vector,\n    public toRadius: number | Handle,\n    public colors: string[],\n    public weights: number[]\n  ) {}\n\n  create(context: CanvasRenderingContext2D): CanvasGradient {\n    let gradient: CanvasGradient;\n    let fromCenter = this.fromOffset.transform(\n      this.node.transform.worldTransform\n    );\n    let toCenter = this.toOffset.transform(this.node.transform.worldTransform);\n    let fromRadius, toRadius;\n    if (this.fromRadius == Handle.AUTO || this.toRadius == Handle.AUTO) {\n      fromRadius = 1;\n      toRadius = this.node.getDimension().max() / 2;\n    } else {\n      fromRadius = this.fromRadius;\n      toRadius = this.toRadius;\n    }\n\n    gradient = context.createRadialGradient(\n      fromCenter.x,\n      fromCenter.y,\n      fromRadius,\n      toCenter.x,\n      toCenter.y,\n      toRadius\n    );\n    this.colors.forEach((color, index) => {\n      gradient.addColorStop(this.weights[index], color);\n    });\n    return gradient;\n  }\n}\n","import { Vector } from \"../math/vector\";\nimport { LinearGradient, RadialGradient } from \"./index\";\nimport { Node } from \"../core/node\";\n\nexport interface RectangleOptions {\n  outline?: boolean;\n  fill?: boolean;\n  outlineColor?: string | LinearGradient | RadialGradient;\n  fillColor?: string | LinearGradient | RadialGradient;\n  outlineWidth?: number;\n  outlineDashSegments?: number[];\n  shadowColor?: string;\n  shadowOffset?: Vector;\n  staticShadow?: boolean;\n  shadowBlur?: number;\n}\n\nexport class Rectangle extends Node {\n  constructor(\n    id: string,\n    position: Vector,\n    width: number,\n    height: number,\n    public props: RectangleOptions = {}\n  ) {\n    super(id, position, [\n      position.add(-width / 2, -height / 2),\n      position.add(width / 2, -height / 2),\n      position.add(width / 2, height / 2),\n      position.add(-width / 2, height / 2),\n    ]);\n\n    if (\n      this.props.outlineColor &&\n      typeof this.props.outlineColor !== \"string\"\n    ) {\n      this.props.outlineColor.node = this;\n    }\n    if (this.props.fillColor && typeof this.props.fillColor !== \"string\") {\n      this.props.fillColor.node = this;\n    }\n  }\n\n  /* istanbul ignore next */\n  _render(): void {\n    if (this.props) {\n      this.props.outlineColor &&\n        (this.context.strokeStyle =\n          typeof this.props.outlineColor == \"string\"\n            ? this.props.outlineColor\n            : this.props.outlineColor.create(this.context));\n      this.props.fillColor &&\n        (this.context.fillStyle =\n          typeof this.props.fillColor == \"string\"\n            ? this.props.fillColor\n            : this.props.fillColor.create(this.context));\n      this.props.outlineWidth &&\n        (this.context.lineWidth = this.props.outlineWidth);\n      this.props.outlineDashSegments &&\n        this.context.setLineDash(this.props.outlineDashSegments);\n      this.props.shadowColor &&\n        (this.context.shadowColor = this.props.shadowColor);\n      this.props.shadowBlur &&\n        (this.context.shadowBlur = this.props.shadowBlur);\n      if (this.props.shadowOffset) {\n        if (!this.props.staticShadow) {\n          let shadowOffset = this.props.shadowOffset\n            .transform(this.transform.worldTransform)\n            .subtract(this.absolutePosition);\n          this.context.shadowOffsetX = shadowOffset.x;\n          this.context.shadowOffsetY = shadowOffset.y;\n        } else {\n          this.context.shadowOffsetX = this.props.shadowOffset.x;\n          this.context.shadowOffsetY = this.props.shadowOffset.y;\n        }\n      }\n    }\n\n    this.context.beginPath();\n    this.context.moveTo(\n      this.transform.controlPoints[0].x,\n      this.transform.controlPoints[0].y\n    );\n    this.context.lineTo(\n      this.transform.controlPoints[1].x,\n      this.transform.controlPoints[1].y\n    );\n    this.context.lineTo(\n      this.transform.controlPoints[2].x,\n      this.transform.controlPoints[2].y\n    );\n    this.context.lineTo(\n      this.transform.controlPoints[3].x,\n      this.transform.controlPoints[3].y\n    );\n    this.context.lineTo(\n      this.transform.controlPoints[0].x,\n      this.transform.controlPoints[0].y\n    );\n    if (this.props.fill) {\n      this.context.fill();\n    }\n    if (this.props.outline || !this.props.fill) {\n      this.context.stroke();\n    }\n  }\n\n  /* istanbul ignore next */\n  _offRender(): void {\n    this.props.outlineWidth &&\n      (this.offContext.lineWidth = this.props.outlineWidth);\n    this.offContext.strokeStyle = this.hitColor;\n    this.offContext.fillStyle = this.hitColor;\n\n    this.offContext.beginPath();\n    this.offContext.moveTo(\n      this.transform.controlPoints[0].x,\n      this.transform.controlPoints[0].y\n    );\n    this.offContext.lineTo(\n      this.transform.controlPoints[1].x,\n      this.transform.controlPoints[1].y\n    );\n    this.offContext.lineTo(\n      this.transform.controlPoints[2].x,\n      this.transform.controlPoints[2].y\n    );\n    this.offContext.lineTo(\n      this.transform.controlPoints[3].x,\n      this.transform.controlPoints[3].y\n    );\n    this.offContext.lineTo(\n      this.transform.controlPoints[0].x,\n      this.transform.controlPoints[0].y\n    );\n    if (this.props.fill) {\n      this.offContext.fill();\n    }\n    if (this.props.outline || !this.props.fill) {\n      this.offContext.stroke();\n    }\n  }\n\n  getDimension(): Vector {\n    return new Vector(\n      Vector.Distance(\n        this.transform.controlPoints[0],\n        this.transform.controlPoints[1]\n      ),\n      Vector.Distance(\n        this.transform.controlPoints[1],\n        this.transform.controlPoints[2]\n      )\n    );\n  }\n}\n","import { Vector } from \"../math/vector\";\nimport { LinearGradient, RadialGradient } from \"./index\";\nimport { Node } from \"../core/node\";\n\nexport interface TextOptions {\n  font?: string;\n  outline?: boolean;\n  fill?: boolean;\n  outlineColor?: string | LinearGradient | RadialGradient;\n  fillColor?: string | LinearGradient | RadialGradient;\n  outlineWidth?: number;\n  shadowColor?: string;\n  shadowOffset?: Vector;\n  staticShadow?: boolean;\n  shadowBlur?: number;\n}\n\nexport class Text extends Node {\n  _text: string;\n  _originalWidth: number;\n  _originalHeight: number;\n\n  get text(): string {\n    return this._text;\n  }\n  set text(text: string) {\n    this._text = text;\n  }\n\n  constructor(\n    id: string,\n    position: Vector,\n    text: string,\n    public props: TextOptions = {}\n  ) {\n    super(id, position, []);\n\n    this.text = text;\n    if (\n      this.props.outlineColor &&\n      typeof this.props.outlineColor !== \"string\"\n    ) {\n      this.props.outlineColor.node = this;\n    }\n    if (this.props.fillColor && typeof this.props.fillColor !== \"string\") {\n      this.props.fillColor.node = this;\n    }\n\n    let textMetricContext = document.createElement(\"canvas\").getContext(\"2d\");\n    this.props.font && (textMetricContext.font = this.props.font);\n    this._originalWidth = textMetricContext.measureText(text).width;\n    this._originalHeight = textMetricContext.measureText(\"M\").width;\n  }\n\n  /* istanbul ignore next */\n  _render(): void {\n    if (this.props) {\n      this.props.outlineColor &&\n        (this.context.strokeStyle =\n          typeof this.props.outlineColor == \"string\"\n            ? this.props.outlineColor\n            : this.props.outlineColor.create(this.context));\n      this.props.fillColor &&\n        (this.context.fillStyle =\n          typeof this.props.fillColor == \"string\"\n            ? this.props.fillColor\n            : this.props.fillColor.create(this.context));\n      this.props.outlineWidth &&\n        (this.context.lineWidth = this.props.outlineWidth);\n      this.props.shadowColor &&\n        (this.context.shadowColor = this.props.shadowColor);\n      this.props.shadowBlur &&\n        (this.context.shadowBlur = this.props.shadowBlur);\n      if (this.props.shadowOffset) {\n        if (!this.props.staticShadow) {\n          let shadowOffset = this.props.shadowOffset\n            .transform(this.transform.worldTransform)\n            .subtract(this.absolutePosition);\n          this.context.shadowOffsetX = shadowOffset.x;\n          this.context.shadowOffsetY = shadowOffset.y;\n        } else {\n          this.context.shadowOffsetX = this.props.shadowOffset.x;\n          this.context.shadowOffsetY = this.props.shadowOffset.y;\n        }\n      }\n      this.props.font && (this.context.font = this.props.font);\n    }\n\n    // Rotate image using worldTransform's rotation component\n    this.context.translate(this.absolutePosition.x, this.absolutePosition.y);\n    this.context.scale(this.scale.x, this.scale.y);\n    this.context.rotate(\n      this.transform.worldTransform.getRotation() * (Math.PI / 180)\n    );\n    this.context.translate(-this.absolutePosition.x, -this.absolutePosition.y);\n\n    this.props.outline &&\n      this.context.strokeText(\n        this.text,\n        this.absolutePosition.x - this._originalWidth / 2,\n        this.absolutePosition.y + this._originalHeight / 2\n      );\n    (this.props.fill || !this.props.outline) &&\n      this.context.fillText(\n        this.text,\n        this.absolutePosition.x - this._originalWidth / 2,\n        this.absolutePosition.y + this._originalHeight / 2\n      );\n  }\n\n  /* istanbul ignore next */\n  _offRender(): void {\n    this.offContext.fillStyle = this.hitColor;\n\n    // Rotate image using worldTransform's rotation component\n    this.offContext.translate(this.absolutePosition.x, this.absolutePosition.y);\n    this.offContext.scale(this.scale.x, this.scale.y);\n    this.offContext.rotate(\n      this.transform.worldTransform.getRotation() * (Math.PI / 180)\n    );\n    this.offContext.translate(\n      -this.absolutePosition.x,\n      -this.absolutePosition.y\n    );\n\n    this.offContext.fillRect(\n      this.absolutePosition.x - this._originalWidth / 2,\n      this.absolutePosition.y - this._originalHeight / 2,\n      this._originalWidth,\n      this._originalHeight\n    );\n  }\n\n  getDimension(): Vector {\n    return new Vector(this._originalWidth, this._originalHeight);\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(229);\n"],"names":["root","factory","exports","module","define","amd","self","Constant","Math","PI","Handle","element","width","height","frameId","HTMLDivElement","this","canvasElement","document","createElement","clientWidth","clientHeight","appendChild","body","context","getContext","OffscreenCanvas","offCanvasElement","offContext","registerObservers","canvasObserver","MutationObserver","mutations","forEach","mutation","type","attributeName","draw","currDrawing","observe","attributes","drawing","stop","render","window","cancelAnimationFrame","requestAnimationFrame","bind","Canvas","Random","floor","random","toString","rgbToHex","rgb","Color","_componentToHex","c","hex","length","debugPoint","key","point","props","frames","Debug","limitDebugCalls","debugCalls","push","debugFunction","_debugPoint","arguments","canvas","clone","center","fillStyle","color","beginPath","arc","x","y","radius","fill","debugLine","from","to","_debugLine","strokeStyle","lineWidth","moveTo","lineTo","stroke","show","debug","call","save","restore","shift","globalUpdate","pointers","rootNode","Empty","Vector","Zero","sceneGraph","colorToNode","_registerEvents","getRelativePosition","ev","canvasOffset","getBoundingClientRect","clientX","left","clientY","top","updatePointer","position","pointer","find","pntr","id","pointerId","removePointer","splice","findIndex","currHitNode","prevHitNode","onpointerdown","_getHitNode","onpointermove","pointerType","hitNode","onpointerup","onpointerout","onclick","oncontextmenu","preventDefault","getImageData","data","clearRect","transform","childs","child","updateWorldTransform","node","add","Node","parent","setContext","setDrawing","setHitColor","cNode","remove","nodeOrID","currentNode","queue","indexOf","_debugSceneGraph","indent","console","log","order","Drawing","controlPoints","Transform","Unit","registeredEvents","zIndex","sort","a","b","newParent","map","absolutePosition","rotation","degrees","localRotation","scale","hitColor","on","eventKey","callback","_render","offRender","_offRender","method","args","dispose","max","Dimension","value","_multiply","another","result","Matrix","Array","i","j","sum","k","multiply","multiplyInPlace","getRotation","atan2","Identity","Multiply","matrix1","matrix2","_position","_localRotation","_rotation","_scale","_parent","localTrasform","worldTransform","refControlPoints","relativeControlPoints","index","newPosition","newRotation","newScale","controlPoint","subtract","applyTransform","_updateWorldTransform","parentWorldTransform","cos","sin","TAU","toFixed","arg1","arg2","addInPlace","subtractInPlace","rotate","pivot","cosT","sinT","rotateInPlace","tmpX","tmpY","matrix","transformInPlace","Midpoint","vector1","vector2","Distance","sqrt","pow","Bounds","vectors","minVec","Number","MAX_SAFE_INTEGER","maxVec","MIN_SAFE_INTEGER","vector","Average","sumX","sumY","minXOrCanvas","maxX","minY","maxY","Lerp","start","end","amount","minor","major","outlineColor","fillColor","create","outlineWidth","outlineDashSegments","setLineDash","shadowColor","shadowBlur","shadowOffset","staticShadow","shadowOffsetX","shadowOffsetY","ellipse","outline","getDimension","Ellipse","source","_source","Image","src","crossOrigin","translate","topLeft","drawImage","fillRect","_from","_to","lineCap","lineDashSegments","Line","offset","colors","weights","gradient","delta","AUTO","createLinearGradient","addColorStop","LinearGradient","vertices","closePath","bounds","abs","Polygon","fromOffset","fromRadius","toOffset","toRadius","fromCenter","toCenter","createRadialGradient","RadialGradient","Rectangle","text","textMetricContext","font","_originalWidth","measureText","_originalHeight","_text","strokeText","fillText","Text","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__"],"sourceRoot":""}