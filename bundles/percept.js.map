{"version":3,"file":"percept.js","mappings":"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","sources":["webpack://Percept/webpack/universalModuleDefinition","webpack://Percept/./src/common/constants.ts","webpack://Percept/./src/common/enums.ts","webpack://Percept/./src/common/index.ts","webpack://Percept/./src/core/canvas.ts","webpack://Percept/./src/core/color.ts","webpack://Percept/./src/core/debug.ts","webpack://Percept/./src/core/drawing.ts","webpack://Percept/./src/core/index.ts","webpack://Percept/./src/core/node.ts","webpack://Percept/./src/math/dimension.ts","webpack://Percept/./src/math/index.ts","webpack://Percept/./src/math/matrix.ts","webpack://Percept/./src/math/transform.ts","webpack://Percept/./src/math/vector.ts","webpack://Percept/./src/percept.ts","webpack://Percept/./src/view/ellipse.ts","webpack://Percept/./src/view/empty.ts","webpack://Percept/./src/view/image.ts","webpack://Percept/./src/view/index.ts","webpack://Percept/./src/view/line.ts","webpack://Percept/./src/view/linear-gradient.ts","webpack://Percept/./src/view/polygon.ts","webpack://Percept/./src/view/radial-gradient.ts","webpack://Percept/./src/view/rectangle.ts","webpack://Percept/./src/view/text.ts","webpack://Percept/webpack/bootstrap","webpack://Percept/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Percept\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Percept\"] = factory();\n\telse\n\t\troot[\"Percept\"] = factory();\n})(self, () => {\nreturn ","export enum Constant {\r\n  TAU = Math.PI / 180,\r\n}\r\n","export enum Handle {\r\n  AUTO = -1,\r\n}\r\n","export * from \"./enums\";\r\nexport * from \"./constants\";\r\n","import { Drawing } from \"./drawing\";\r\n\r\n/**\r\n * The Canvas object holds an HTMLCanvasElement reference and its 2d context\r\n */\r\nexport class Canvas {\r\n  canvasElement: HTMLCanvasElement;\r\n  context: CanvasRenderingContext2D;\r\n  offCanvasElement: OffscreenCanvas | HTMLCanvasElement;\r\n  offContext: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D;\r\n\r\n  width: number;\r\n  height: number;\r\n  private frameId: number = 0;\r\n\r\n  /**\r\n   * If no parameters are passed then a new canvas element will be created and appended to `<body>`\r\n   *\r\n   * @param element Reference to an html `<canvas>` or `<div>` element, if a `<div>` element is passed, then a canvas will be created and appended\r\n   * @param width Passing a width will overwrite previously defined canvas width\r\n   * @param height Passing a height will overwrite previously defined canvas height\r\n   */\r\n  constructor(\r\n    element?: HTMLCanvasElement | HTMLDivElement,\r\n    width?: number,\r\n    height?: number\r\n  ) {\r\n    if (!element) {\r\n      this.canvasElement = document.createElement(\"canvas\");\r\n      this.canvasElement.width = document.body.clientWidth;\r\n      this.canvasElement.height = document.body.clientHeight;\r\n      document.body.appendChild(this.canvasElement);\r\n    } else {\r\n      if (element instanceof HTMLDivElement) {\r\n        this.canvasElement = document.createElement(\"canvas\");\r\n        if (width && height) {\r\n          this.canvasElement.width = width;\r\n          this.canvasElement.height = height;\r\n        } else {\r\n          this.canvasElement.width = element.clientWidth;\r\n          this.canvasElement.height = element.clientHeight;\r\n        }\r\n        element.appendChild(this.canvasElement);\r\n      } else {\r\n        this.canvasElement = element;\r\n        if (width && height) {\r\n          this.canvasElement.width = width;\r\n          this.canvasElement.height = height;\r\n        }\r\n      }\r\n    }\r\n    this.width = this.canvasElement.width;\r\n    this.height = this.canvasElement.height;\r\n    this.context = this.canvasElement.getContext(\"2d\");\r\n\r\n    if (typeof OffscreenCanvas !== \"undefined\") {\r\n      this.offCanvasElement = new OffscreenCanvas(this.width, this.height);\r\n      this.offContext = this.offCanvasElement.getContext(\"2d\");\r\n    } else {\r\n      this.offCanvasElement = document.createElement(\"canvas\");\r\n      this.offCanvasElement.width = this.width;\r\n      this.offCanvasElement.height = this.height;\r\n      this.offContext = this.offCanvasElement.getContext(\"2d\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calls render function of `Drawing`\r\n   *\r\n   * @param drawing A `Drawing` object, which will be rendered by this canvas\r\n   */\r\n  draw(drawing: Drawing) {\r\n    this.stop();\r\n    this.render(drawing);\r\n  }\r\n\r\n  /**\r\n   * Stops rendering current Drawing\r\n   */\r\n  stop() {\r\n    window.cancelAnimationFrame(this.frameId);\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  private render(drawing: Drawing) {\r\n    drawing.render();\r\n    if (this.frameId < 0) return;\r\n    this.frameId = window.requestAnimationFrame(\r\n      this.render.bind(this, drawing)\r\n    );\r\n  }\r\n}\r\n","export class Color {\r\n  static Random(): string {\r\n    return \"#\" + Math.floor(Math.random() * 16777215).toString(16);\r\n  }\r\n\r\n  static rgbToHex(rgb: number[] | Uint8ClampedArray): string {\r\n    return (\r\n      \"#\" +\r\n      Color._componentToHex(rgb[0]) +\r\n      Color._componentToHex(rgb[1]) +\r\n      Color._componentToHex(rgb[2])\r\n    );\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  private static _componentToHex(c: number) {\r\n    let hex = c.toString(16);\r\n    return hex.length == 1 ? \"0\" + hex : hex;\r\n  }\r\n}\r\n","import { Drawing, DebugCall } from \".\";\nimport { Vector } from \"../math/vector\";\n\n/**\n * Includes static methods for debugging\n */\nexport class Debug {\n  /**\n   * Will render a filled circle denoting a single point on canvas\n   *\n   * @param key A unique name for this debug\n   * @param drawing Drawing, on which this debug will render\n   * @param point The point to render\n   * @param props Styling properties for debug\n   * @param frames Specifies for how many frames this debug will persist (e.g passing 100 will allow this debug to be rendered for 100 consecutive frames without clearing it from canvas)\n   */\n  static debugPoint(\n    key: string,\n    drawing: Drawing,\n    point: Vector,\n    props: { color: string; radius?: number },\n    frames?: number\n  ) {\n    Debug.limitDebugCalls(drawing, key, frames);\n\n    drawing.debugCalls[key].push({\n      debugFunction: Debug._debugPoint,\n      arguments: [drawing.canvas.context, point.clone(), props],\n    });\n  }\n\n  /* istanbul ignore next */\n  private static _debugPoint(\n    context: CanvasRenderingContext2D,\n    center: Vector,\n    props: { color: string; radius?: number }\n  ) {\n    context.fillStyle = props.color;\n    context.beginPath();\n    context.arc(\n      center.x,\n      center.y,\n      props.radius ? props.radius : 2,\n      0,\n      2 * Math.PI\n    );\n    context.fill();\n  }\n\n  /**\n   * Will render a line with green and red dots on start and end co-ordinates of line\n   *\n   * @param key A unique name for this debug\n   * @param drawing Drawing, on which this debug will render\n   * @param from Start Vector for this line\n   * @param to End Vector point for this line\n   * @param props Styling properties for debug\n   * @param frames Specifies for how many frames this debug will persist (e.g passing 100 will allow this debug to be rendered for 100 consecutive frames without clearing it from canvas)\n   */\n  static debugLine(\n    key: string,\n    drawing: Drawing,\n    from: Vector,\n    to: Vector,\n    props: { color: string; width?: number },\n    frames?: number\n  ) {\n    Debug.limitDebugCalls(drawing, key, frames);\n\n    drawing.debugCalls[key].push({\n      debugFunction: Debug._debugLine,\n      arguments: [drawing.canvas.context, from.clone(), to.clone(), props],\n    });\n  }\n\n  /* istanbul ignore next */\n  private static _debugLine(\n    context: CanvasRenderingContext2D,\n    from: Vector,\n    to: Vector,\n    props: { color: string; width?: number }\n  ) {\n    context.strokeStyle = props.color;\n    context.lineWidth = props.width ? props.width : 1;\n    context.beginPath();\n    context.moveTo(from.x, from.y);\n    context.lineTo(to.x, to.y);\n    context.stroke();\n\n    context.fillStyle = \"green\";\n    context.beginPath();\n    context.arc(from.x, from.y, 2, 0, 2 * Math.PI);\n    context.fill();\n\n    context.fillStyle = \"red\";\n    context.beginPath();\n    context.arc(to.x, to.y, 2, 0, 2 * Math.PI);\n    context.fill();\n  }\n\n  /**\n   * @hidden\n   *\n   * Starts debug render calls stored in debugCalls\n   */\n  static show(\n    debugCalls: Record<string, DebugCall[]>,\n    context: CanvasRenderingContext2D\n  ) {\n    for (let debug in debugCalls) {\n      for (let call of debugCalls[debug]) {\n        context.save();\n        call.debugFunction(...call.arguments);\n        context.restore();\n      }\n    }\n  }\n\n  // Used for persisting the debug calls on canvas (shifts array of debug calls to limit array size to frames)\n  /* istanbul ignore next */\n  private static limitDebugCalls(\n    drawing: Drawing,\n    key: string,\n    frames: number\n  ) {\n    if (\n      frames &&\n      drawing.debugCalls[key] &&\n      frames - 1 < drawing.debugCalls[key].length\n    ) {\n      drawing.debugCalls[key].shift();\n    } else {\n      (!drawing.debugCalls[key] || !frames) && (drawing.debugCalls[key] = []);\n    }\n  }\n}\n","import { Canvas, Debug, Node, Color } from \".\";\nimport { Vector } from \"../math/vector\";\nimport { Empty } from \"../view/empty\";\n\nexport interface DebugCall {\n  debugFunction: Function;\n  arguments: any[];\n  frames?: number;\n}\n\n/**\n * Stores all views which will be rendered by canvas\n */\nexport class Drawing {\n  // Scene-graph root node\n  private sceneGraph: Node;\n  /**@hidden */\n  debugCalls: Record<string, DebugCall[]>;\n\n  colorToNode: { [key: string]: Node };\n  mousePos: Vector;\n\n  /**\n   *\n   * @param canvas The Canvas object\n   * @param globalUpdate A function that will be called per frame\n   */\n  constructor(public canvas: Canvas, public globalUpdate?: Function) {\n    let rootNode = new Empty(\"#Root\", Vector.Zero());\n    rootNode.context = this.canvas.context;\n    rootNode.drawing = this;\n    this.sceneGraph = rootNode;\n    this.debugCalls = {};\n\n    this.mousePos = Vector.Zero();\n    this.colorToNode = {};\n    this._registerEvents();\n  }\n\n  /* istanbul ignore next */\n  private _registerEvents(): void {\n    let currentHitNode: Node, prevHitNode: Node;\n    let currentDragNode: Node = null;\n    let canvasOffset: DOMRect;\n\n    this.canvas.canvasElement.onmousemove = (ev) => {\n      canvasOffset = this.canvas.canvasElement.getBoundingClientRect();\n      this.mousePos.x = ev.clientX - canvasOffset.left;\n      this.mousePos.y = ev.clientY - canvasOffset.top;\n\n      currentHitNode = this._getHitNode(this.mousePos);\n      if (currentHitNode != prevHitNode) {\n        prevHitNode && prevHitNode.call(\"mouseexit\");\n        currentHitNode && currentHitNode.call(\"mouseenter\");\n      }\n      prevHitNode = currentHitNode;\n\n      currentDragNode && currentDragNode.call(\"drag\", [this.mousePos.clone()]);\n    };\n\n    this.canvas.canvasElement.onmousedown = () => {\n      currentDragNode = currentHitNode;\n\n      let hitNode = this._getHitNode(this.mousePos);\n      hitNode && hitNode.call(\"mousedown\");\n    };\n\n    this.canvas.canvasElement.onmouseup = () => {\n      currentDragNode = null;\n\n      let hitNode = this._getHitNode(this.mousePos);\n      hitNode && hitNode.call(\"mouseup\");\n    };\n\n    this.canvas.canvasElement.onclick = () => {\n      let hitNode = this._getHitNode(this.mousePos);\n      hitNode && hitNode.call(\"click\");\n    };\n\n    this.canvas.canvasElement.oncontextmenu = (ev) => {\n      ev.preventDefault();\n\n      let hitNode = this._getHitNode(this.mousePos);\n      hitNode && hitNode.call(\"rightclick\");\n    };\n  }\n\n  /* istanbul ignore next */\n  private _getHitNode(position: Vector): Node {\n    return this.colorToNode[\n      Color.rgbToHex(\n        this.canvas.offContext.getImageData(position.x, position.y, 1, 1).data\n      )\n    ];\n  }\n\n  /** @hidden */\n  render() {\n    this.canvas.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    this.canvas.offContext.clearRect(\n      0,\n      0,\n      this.canvas.width,\n      this.canvas.height\n    );\n\n    this.sceneGraph.call(\"update\");\n\n    this.globalUpdate && this.globalUpdate();\n\n    this.sceneGraph.transform.childs.forEach((child) => {\n      child.updateWorldTransform();\n    });\n\n    this.sceneGraph.transform.childs.forEach((child) => {\n      child.node.render();\n    });\n\n    Debug.show(this.debugCalls, this.canvas.context);\n  }\n\n  /**\n   * Adds a view object to this drawing\n   *\n   * @param node A View object to be rendered\n   */\n  add(node: Node | Node[]): void {\n    if (node instanceof Node) {\n      node.parent = this.sceneGraph;\n      node.setContext(this.canvas.context, this.canvas.offContext);\n      node.setDrawing(this);\n      node.setHitColor();\n    } else {\n      node.forEach((cNode) => {\n        cNode.parent = this.sceneGraph;\n        cNode.setContext(this.canvas.context, this.canvas.offContext);\n        cNode.setDrawing(this);\n        cNode.setHitColor();\n      });\n    }\n  }\n\n  /**\n   * Removes a view object from this drawing\n   *\n   * @param nodeOrID A View object or its id\n   */\n  remove(nodeOrID: Node | string) {\n    if (nodeOrID instanceof Node) nodeOrID = nodeOrID.id;\n\n    let queue = [];\n    let currentNode;\n    queue.push(this.sceneGraph);\n\n    while ((currentNode = queue.shift())) {\n      if (currentNode.id == nodeOrID) {\n        currentNode.transform.parent.childs.splice(\n          currentNode.transform.parent.childs.indexOf(currentNode.transform),\n          1\n        );\n      } else {\n        currentNode.transform.childs.forEach((child) => {\n          queue.push(child.node);\n        });\n      }\n    }\n  }\n\n  /* istanbul ignore next */\n  private _debugSceneGraph(root: Node, indent: string): void {\n    console.log(indent + root.id + \"[\" + root.order + \"]\");\n\n    root.transform.childs.forEach((child) => {\n      this._debugSceneGraph(child.node, \" \" + indent);\n    });\n  }\n}\n","export * from \"./canvas\";\r\nexport * from \"./color\";\r\nexport * from \"./debug\";\r\nexport * from \"./drawing\";\r\nexport * from \"./event\";\r\nexport * from \"./node\";\r\n","import { Transform, Vector } from \"../math\";\nimport { Drawing } from \"./drawing\";\nimport { Event } from \"./event\";\nimport { Color } from \"./color\";\n\nexport abstract class Node implements Event {\n  drawing: Drawing;\n  context: CanvasRenderingContext2D;\n  offContext: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D;\n  transform: Transform;\n  registeredEvents: any;\n  order: number;\n  hitColor: string;\n\n  abstract _render(): void;\n  abstract _offRender(): void;\n  abstract getDimension(): Vector;\n\n  get zIndex(): number {\n    return this.order;\n  }\n  set zIndex(zIndex: number) {\n    this.order = zIndex;\n\n    if (this.parent) {\n      this.parent.transform.childs.sort((a, b) => {\n        return a.node.order - b.node.order;\n      });\n    }\n  }\n\n  get parent(): Node {\n    return this.transform.parent.node;\n  }\n  set parent(newParent: Node) {\n    this.transform.parent = newParent.transform;\n  }\n\n  get childs(): Node[] {\n    return this.transform.childs.map((child) => {\n      return child.node;\n    });\n  }\n\n  get position(): Vector {\n    return this.transform.position;\n  }\n  set position(position: Vector) {\n    this.transform.position = position;\n  }\n  get absolutePosition(): Vector {\n    return this.transform.absolutePosition;\n  }\n\n  get rotation(): number {\n    return this.transform.rotation;\n  }\n  set rotation(degrees: number) {\n    this.transform.rotation = degrees;\n  }\n\n  get localRotation(): number {\n    return this.transform.localRotation;\n  }\n  set localRotation(degrees: number) {\n    this.transform.localRotation = degrees;\n  }\n\n  get scale(): Vector {\n    return this.transform.scale;\n  }\n  set scale(scale: Vector) {\n    this.transform.scale = scale;\n  }\n\n  constructor(public id: string, position: Vector, controlPoints: Vector[]) {\n    this.transform = new Transform(\n      position,\n      0,\n      0,\n      Vector.Unit(),\n      controlPoints,\n      this\n    );\n    this.registeredEvents = {};\n    this.order = 0;\n  }\n\n  setHitColor() {\n    // Set unique color for hit detection in offscreen canvas\n    let color: string = Color.Random();\n    while (this.drawing.colorToNode[color]) {\n      color = Color.Random();\n    }\n\n    this.hitColor = color;\n    this.drawing.colorToNode[color] = this;\n\n    this.transform.childs.forEach((child) => {\n      child.node.setHitColor();\n    });\n  }\n\n  on(eventKey: string, callback: Function): void {\n    this.registeredEvents[eventKey] = callback;\n  }\n\n  render(): void {\n    this.context.save();\n    this._render();\n    this.context.restore();\n    this.offRender();\n\n    for (var child of this.transform.childs) {\n      child.node.render();\n    }\n  }\n\n  offRender(): void {\n    this.offContext.save();\n    this._offRender();\n    this.offContext.restore();\n  }\n\n  call(method: string, args?: any[]) {\n    if (this.registeredEvents[method]) {\n      if (args) {\n        this.registeredEvents[method](this, ...args);\n      } else {\n        this.registeredEvents[method](this);\n      }\n    }\n\n    for (var child of this.transform.childs) {\n      child.node.call(method, args);\n    }\n  }\n\n  setContext(\n    context: CanvasRenderingContext2D,\n    offContext: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D\n  ) {\n    this.context = context;\n    this.offContext = offContext;\n    this.transform.childs.forEach((child) => {\n      child.node.setContext(context, offContext);\n    });\n  }\n\n  setDrawing(drawing: Drawing) {\n    this.drawing = drawing;\n    this.transform.childs.forEach((child) => {\n      child.node.setDrawing(drawing);\n    });\n  }\n\n  dispose(): void {\n    this.drawing.remove(this.id);\n  }\n}\n","export class Dimension {\r\n  constructor(public width: number, public height: number) {}\r\n\r\n  max() {\r\n    return Math.max(this.width, this.height);\r\n  }\r\n}\r\n","export * from \"./dimension\";\r\nexport * from \"./matrix\";\r\nexport * from \"./transform\";\r\nexport * from \"./vector\";\r\n","/**\n * A 3x3 Matrix\n */\nexport class Matrix {\n  value: number[][];\n\n  constructor(value: number[][]) {\n    this.value = value;\n  }\n\n  /* istanbul ignore next */\n  private _multiply(another: Matrix | number[][]): number[][] {\n    let result;\n    if (another instanceof Matrix) {\n      result = [...Array(this.value.length)].map(() =>\n        Array(another.value[0].length)\n      );\n\n      for (let i = 0; i < this.value.length; i++) {\n        for (let j = 0; j < another.value[0].length; j++) {\n          let sum = 0;\n          for (let k = 0; k < this.value[0].length; k++) {\n            sum += this.value[i][k] * another.value[k][j];\n          }\n          result[i][j] = sum;\n        }\n      }\n    } else {\n      result = [...Array(this.value.length)].map(() =>\n        Array(another[0].length)\n      );\n\n      for (let i = 0; i < this.value.length; i++) {\n        for (let j = 0; j < another[0].length; j++) {\n          let sum = 0;\n          for (let k = 0; k < this.value[0].length; k++) {\n            sum += this.value[i][k] * another[k][j];\n          }\n          result[i][j] = sum;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  multiply(another: Matrix | number[][]): Matrix {\n    return new Matrix(this._multiply(another));\n  }\n\n  multiplyInPlace(another: Matrix | number[][]): Matrix {\n    this.value = this._multiply(another);\n    return this;\n  }\n\n  clone() {\n    return new Matrix([\n      [this.value[0][0], this.value[0][1], this.value[0][2]],\n      [this.value[1][0], this.value[1][1], this.value[1][2]],\n      [this.value[2][0], this.value[2][1], this.value[2][2]],\n    ]);\n  }\n\n  /**\n   * Decomposes the rotation component from matrix to get absolute rotation for a child transform\n   */\n  getRotation(): number {\n    return Math.atan2(this.value[0][1], this.value[0][0]) * (180 / Math.PI);\n  }\n\n  static Identity() {\n    return new Matrix([\n      [1, 0, 0],\n      [0, 1, 0],\n      [0, 0, 1],\n    ]);\n  }\n\n  static Zero() {\n    return new Matrix([\n      [0, 0, 0],\n      [0, 0, 0],\n      [0, 0, 0],\n    ]);\n  }\n\n  static Multiply(matrix1: number[][], matrix2: number[][]) {\n    let result = [...Array(matrix1.length)].map(() => Array(matrix2[0].length));\n\n    for (let i = 0; i < matrix1.length; i++) {\n      for (let j = 0; j < matrix2[0].length; j++) {\n        let sum = 0;\n        for (let k = 0; k < matrix1[0].length; k++) {\n          sum += matrix1[i][k] * matrix2[k][j];\n        }\n        result[i][j] = sum;\n      }\n    }\n\n    return result;\n  }\n}\n","import { Matrix, Vector } from \"./index\";\nimport { Constant } from \"../common/constants\";\nimport { Node } from \"../core/node\";\n\n// Stores a node's transform (position, rotation, scale)\nexport class Transform {\n  // reference control points to apply transform to\n  refControlPoints: Vector[];\n  // transformed control points\n  controlPoints: Vector[];\n  localTrasform: Matrix;\n  worldTransform: Matrix;\n  childs: Transform[];\n  private _parent: Transform;\n  private _position: Vector;\n  private _localRotation: number;\n  private _rotation: number;\n  private _scale: Vector;\n\n  get parent(): Transform {\n    return this._parent;\n  }\n  set parent(newParent: Transform) {\n    if (this._parent) {\n      const index = this._parent.childs.indexOf(this);\n      if (index > -1) {\n        this._parent.childs.splice(index, 1);\n      }\n    }\n    newParent && newParent.childs.push(this);\n    this._parent = newParent;\n\n    if (this._parent) {\n      this._parent.childs.sort((a, b) => {\n        return a.node.order - b.node.order;\n      });\n    }\n  }\n\n  get position(): Vector {\n    return this._position;\n  }\n  set position(newPosition: Vector) {\n    this._position = newPosition;\n  }\n\n  get absolutePosition(): Vector {\n    return Vector.Zero().transform(this.worldTransform);\n  }\n\n  get rotation(): number {\n    return this._rotation;\n  }\n  set rotation(degrees: number) {\n    this._rotation = degrees % 360;\n  }\n\n  get localRotation(): number {\n    return this._localRotation;\n  }\n  set localRotation(newRotation: number) {\n    this._localRotation = newRotation % 360;\n  }\n\n  get scale(): Vector {\n    return this._scale;\n  }\n  set scale(newScale: Vector) {\n    this._scale = newScale;\n  }\n\n  constructor(\n    position: Vector,\n    localRotation: number,\n    rotation: number,\n    scale: Vector,\n    controlPoints: Vector[],\n    public node: Node\n  ) {\n    this._position = position;\n    this._localRotation = localRotation;\n    this._rotation = rotation;\n    this._scale = scale;\n    this._parent = null;\n    this.childs = [];\n    this.localTrasform = Matrix.Identity();\n    this.worldTransform = Matrix.Identity();\n    this.refControlPoints = this.relativeControlPoints(controlPoints);\n    this.controlPoints = [...controlPoints];\n  }\n\n  /* istanbul ignore next */\n  private relativeControlPoints(controlPoints: Vector[]): Vector[] {\n    let result: Vector[] = [];\n    controlPoints.forEach((controlPoint) => {\n      result.push(controlPoint.subtract(this.position));\n    });\n    return result;\n  }\n\n  // Transforms each control point using this node's worldTransform\n  /* istanbul ignore next */\n  private applyTransform() {\n    this.refControlPoints.forEach((controlPoint, index) => {\n      this.controlPoints[index] = controlPoint.transform(this.worldTransform);\n    });\n  }\n\n  /* istanbul ignore next */\n  private _updateWorldTransform(parentWorldTransform?: Matrix) {\n    // Set translation\n    this.localTrasform.value = [\n      [1, 0, 0],\n      [0, 1, 0],\n      [this.position.x, this.position.y, 1],\n    ];\n\n    let cos;\n    let sin;\n    // Transform rotation\n    if (this.parent.node.id != \"#Root\") {\n      cos = Math.cos(this.rotation * Constant.TAU);\n      sin = Math.sin(this.rotation * Constant.TAU);\n\n      this.localTrasform = new Matrix([\n        [1, 0, 0],\n        [0, 1, 0],\n        [this.position.x, this.position.y, 1],\n      ])\n        .multiply([\n          [cos, sin, 0],\n          [-sin, cos, 0],\n          [0, 0, 1],\n        ])\n        .multiply([\n          [1, 0, 0],\n          [0, 1, 0],\n          [-this.position.x, -this.position.y, 1],\n        ])\n        .multiply(this.localTrasform);\n    }\n\n    // Transform localRotation\n    cos = Math.cos(this.localRotation * Constant.TAU);\n    sin = Math.sin(this.localRotation * Constant.TAU);\n    this.localTrasform = new Matrix([\n      [cos, sin, 0],\n      [-sin, cos, 0],\n      [0, 0, 1],\n    ]).multiply(this.localTrasform);\n\n    // Transform scale\n    this.localTrasform = new Matrix([\n      [this.scale.x, 0, 0],\n      [0, this.scale.y, 0],\n      [0, 0, 1],\n    ]).multiply(this.localTrasform);\n\n    if (parentWorldTransform) {\n      this.worldTransform = this.localTrasform.multiply(parentWorldTransform);\n    } else {\n      this.worldTransform = this.localTrasform.clone();\n    }\n\n    this.childs.forEach((child) => {\n      child.updateWorldTransform(this.worldTransform);\n    });\n\n    this.applyTransform();\n  }\n\n  // Updates this node's worldTransform using parent's worldTransform if any\n  updateWorldTransform(parentWorldTransform?: Matrix) {\n    this._updateWorldTransform(parentWorldTransform);\n  }\n}\n","import { Canvas } from \"../core/canvas\";\nimport { Constant } from \"../common/constants\";\nimport { Matrix } from \"../math/matrix\";\n\n/**\n * Stores 2D Vector\n */\nexport class Vector {\n  tmpX: number;\n  tmpY: number;\n\n  constructor(public x: number, public y: number) {}\n\n  toString() {\n    return \"[\" + this.x.toFixed(3) + \", \" + this.y.toFixed(3) + \"]\";\n  }\n\n  add(x: number, y: number): Vector;\n  add(value: number): Vector;\n  add(vector: Vector): Vector;\n  add(arg1: number | Vector, arg2?: number): Vector {\n    // Params : (vector) or (x, y)\n    if (arg1 instanceof Vector) {\n      return new Vector(this.x + arg1.x, this.y + arg1.y);\n    } else if (typeof arg2 === \"undefined\") {\n      return new Vector(this.x + arg1, this.y + arg1);\n    } else {\n      return new Vector(this.x + arg1, this.y + arg2);\n    }\n  }\n\n  addInPlace(x: number, y: number): Vector;\n  addInPlace(value: number): Vector;\n  addInPlace(vector: Vector): Vector;\n  addInPlace(arg1: number | Vector, arg2?: number): Vector {\n    // Params : (vector) or (x, y)\n    if (arg1 instanceof Vector) {\n      this.x += arg1.x;\n      this.y += arg1.y;\n    } else if (typeof arg2 === \"undefined\") {\n      this.x += arg1;\n      this.y += arg1;\n    } else {\n      this.x += arg1;\n      this.y += arg2;\n    }\n    return this;\n  }\n\n  multiply(x: number, y: number): Vector;\n  multiply(value: number): Vector;\n  multiply(vector: Vector): Vector;\n  multiply(arg1: number | Vector, arg2?: number): Vector {\n    // Params : (vector) or (x, y)\n    if (arg1 instanceof Vector) {\n      return new Vector(this.x * arg1.x, this.y * arg1.y);\n    } else if (typeof arg2 === \"undefined\") {\n      return new Vector(this.x * arg1, this.y * arg1);\n    } else {\n      return new Vector(this.x * arg1, this.y * arg2);\n    }\n  }\n\n  multiplyInPlace(x: number, y: number): Vector;\n  multiplyInPlace(value: number): Vector;\n  multiplyInPlace(vector: Vector): Vector;\n  multiplyInPlace(arg1: number | Vector, arg2?: number): Vector {\n    // Params : (vector) or (x, y)\n    if (arg1 instanceof Vector) {\n      this.x *= arg1.x;\n      this.y *= arg1.y;\n    } else if (typeof arg2 === \"undefined\") {\n      this.x *= arg1;\n      this.y *= arg1;\n    } else {\n      this.x *= arg1;\n      this.y *= arg2;\n    }\n    return this;\n  }\n\n  subtract(x: number, y: number): Vector;\n  subtract(value: number): Vector;\n  subtract(vector: Vector): Vector;\n  subtract(arg1: number | Vector, arg2?: number): Vector {\n    // Params : (vector) or (x, y)\n    if (arg1 instanceof Vector) {\n      return new Vector(this.x - arg1.x, this.y - arg1.y);\n    } else if (typeof arg2 === \"undefined\") {\n      return new Vector(this.x - arg1, this.y - arg1);\n    } else {\n      return new Vector(this.x - arg1, this.y - arg2);\n    }\n  }\n\n  subtractInPlace(x: number, y: number): Vector;\n  subtractInPlace(value: number): Vector;\n  subtractInPlace(vector: Vector): Vector;\n  subtractInPlace(arg1: number | Vector, arg2?: number): Vector {\n    // Params : (vector) or (x, y)\n    if (arg1 instanceof Vector) {\n      this.x -= arg1.x;\n      this.y -= arg1.y;\n    } else if (typeof arg2 === \"undefined\") {\n      this.x -= arg1;\n      this.y -= arg1;\n    } else {\n      this.x -= arg1;\n      this.y -= arg2;\n    }\n\n    return this;\n  }\n\n  rotate(pivot: Vector, degrees: number): Vector {\n    degrees = degrees * Constant.TAU;\n    let cosT = Math.cos(degrees);\n    let sinT = Math.sin(degrees);\n    return new Vector(\n      cosT * (this.x - pivot.x) - sinT * (this.y - pivot.y) + pivot.x,\n      sinT * (this.x - pivot.x) + cosT * (this.y - pivot.y) + pivot.y\n    );\n  }\n\n  rotateInPlace(pivot: Vector, degrees: number): Vector {\n    degrees = degrees * Constant.TAU;\n    let cosT = Math.cos(degrees);\n    let sinT = Math.sin(degrees);\n    this.tmpX = cosT * (this.x - pivot.x) - sinT * (this.y - pivot.y) + pivot.x;\n    this.tmpY = sinT * (this.x - pivot.x) + cosT * (this.y - pivot.y) + pivot.y;\n    this.x = this.tmpX;\n    this.y = this.tmpY;\n    return this;\n  }\n\n  transform(matrix: Matrix) {\n    let result = Matrix.Multiply([[this.x, this.y, 1]], matrix.value);\n    return new Vector(result[0][0], result[0][1]);\n  }\n\n  transformInPlace(matrix: Matrix): Vector {\n    let result = Matrix.Multiply([[this.x, this.y, 1]], matrix.value);\n    this.x = result[0][0];\n    this.y = result[0][1];\n    return this;\n  }\n\n  max() {\n    return Math.max(this.x, this.y);\n  }\n\n  static Midpoint(vector1: Vector, vector2: Vector): Vector {\n    return new Vector((vector1.x + vector2.x) / 2, (vector1.y + vector2.y) / 2);\n  }\n\n  static Distance(vector1: Vector, vector2: Vector): number {\n    return Math.sqrt(\n      Math.pow(vector2.x - vector1.x, 2) + Math.pow(vector2.y - vector1.y, 2)\n    );\n  }\n\n  static Zero(): Vector {\n    return new Vector(0, 0);\n  }\n\n  static Unit(): Vector {\n    return new Vector(1, 1);\n  }\n\n  static Bounds(vectors: Vector[]): Vector[] {\n    let minVec = new Vector(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\n    let maxVec = new Vector(Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);\n\n    vectors.forEach((vector) => {\n      if (vector.x < minVec.x) minVec.x = vector.x;\n      if (vector.y < minVec.y) minVec.y = vector.y;\n      if (vector.x > maxVec.x) maxVec.x = vector.x;\n      if (vector.y > maxVec.y) maxVec.y = vector.y;\n    });\n    return [minVec, maxVec];\n  }\n\n  static Average(vectors: Vector[]): Vector {\n    let sumX = 0;\n    let sumY = 0;\n    vectors.forEach((vector) => {\n      sumX += vector.x;\n      sumY += vector.y;\n    });\n    return new Vector(sumX / vectors.length, sumY / vectors.length);\n  }\n\n  static Random(canvas: Canvas): Vector;\n  static Random(minX: number, maxX: number, minY: number, maxY: number): Vector;\n  static Random(\n    minXOrCanvas: number | Canvas,\n    maxX?: number,\n    minY?: number,\n    maxY?: number\n  ): Vector {\n    if (minXOrCanvas instanceof Canvas) {\n      return new Vector(\n        Math.random() * minXOrCanvas.width,\n        Math.random() * minXOrCanvas.height\n      );\n    } else {\n      return new Vector(\n        Math.random() * (maxX - minXOrCanvas) + minXOrCanvas,\n        Math.random() * (maxY - minY) + minY\n      );\n    }\n  }\n\n  static Lerp(start: Vector, end: Vector, amount: number): Vector {\n    return new Vector(\n      start.x + (end.x - start.x) * amount,\n      start.y + (end.y - start.y) * amount\n    );\n  }\n\n  clone(): Vector {\n    return new Vector(this.x, this.y);\n  }\n}\n","export * from \"./common\";\r\nexport * as View from \"./view\";\r\nexport * from \"./core\";\r\nexport * from \"./math\";\r\n","import { Vector } from \"../math/vector\";\nimport { LinearGradient, RadialGradient } from \".\";\nimport { Node } from \"../core/node\";\n\nexport interface EllipseOptions {\n  outline?: boolean;\n  fill?: boolean;\n  outlineColor?: string | LinearGradient | RadialGradient;\n  fillColor?: string | LinearGradient | RadialGradient;\n  outlineWidth?: number;\n  outlineDashSegments?: number[];\n  shadowColor?: string;\n  shadowOffset?: Vector;\n  staticShadow?: boolean;\n  shadowBlur?: number;\n}\n\nexport class Ellipse extends Node {\n  constructor(\n    id: string,\n    position: Vector,\n    public minor: number,\n    public major: number,\n    public props?: EllipseOptions\n  ) {\n    super(id, position, [\n      position.subtract(0, minor),\n      position.add(major, 0),\n      position.add(0, minor),\n      position.subtract(major, 0),\n    ]);\n\n    !props && (this.props = {});\n    if (this.props.outlineColor && typeof this.props.outlineColor != \"string\") {\n      this.props.outlineColor.node = this;\n    }\n    if (this.props.fillColor && typeof this.props.fillColor != \"string\") {\n      this.props.fillColor.node = this;\n    }\n  }\n\n  _render(): void {\n    if (this.props) {\n      this.props.outlineColor &&\n        (this.context.strokeStyle =\n          typeof this.props.outlineColor == \"string\"\n            ? this.props.outlineColor\n            : this.props.outlineColor.create(this.context));\n      this.props.fillColor &&\n        (this.context.fillStyle =\n          typeof this.props.fillColor == \"string\"\n            ? this.props.fillColor\n            : this.props.fillColor.create(this.context));\n      this.props.outlineWidth &&\n        (this.context.lineWidth = this.props.outlineWidth);\n      this.props.outlineDashSegments &&\n        this.context.setLineDash(this.props.outlineDashSegments);\n      this.props.shadowColor &&\n        (this.context.shadowColor = this.props.shadowColor);\n      this.props.shadowBlur &&\n        (this.context.shadowBlur = this.props.shadowBlur);\n      if (this.props.shadowOffset) {\n        if (!this.props.staticShadow) {\n          let shadowOffset = this.props.shadowOffset\n            .transform(this.transform.worldTransform)\n            .subtract(this.absolutePosition);\n          this.context.shadowOffsetX = shadowOffset.x;\n          this.context.shadowOffsetY = shadowOffset.y;\n        } else {\n          this.context.shadowOffsetX = this.props.shadowOffset.x;\n          this.context.shadowOffsetY = this.props.shadowOffset.y;\n        }\n      }\n    }\n\n    let position = this.absolutePosition;\n    this.context.beginPath();\n    if (this.minor == this.major) {\n      this.context.arc(position.x, position.y, this.minor, 0, 2 * Math.PI);\n    } else {\n      this.context.ellipse(\n        position.x,\n        position.y,\n        this.major,\n        this.minor,\n        Math.atan2(\n          this.transform.controlPoints[1].y - position.y,\n          this.transform.controlPoints[1].x - position.x\n        ),\n        0,\n        2 * Math.PI\n      );\n    }\n    if (this.props.fill) {\n      this.context.fill();\n    }\n    if (this.props.outline || !this.props.fill) {\n      this.context.stroke();\n    }\n  }\n\n  _offRender(): void {\n    this.props.outlineWidth &&\n      (this.offContext.lineWidth = this.props.outlineWidth);\n    this.offContext.strokeStyle = this.hitColor;\n    this.offContext.fillStyle = this.hitColor;\n\n    let position = this.absolutePosition;\n    this.offContext.beginPath();\n    if (this.minor == this.major) {\n      this.offContext.arc(position.x, position.y, this.minor, 0, 2 * Math.PI);\n    } else {\n      this.offContext.ellipse(\n        position.x,\n        position.y,\n        this.major,\n        this.minor,\n        Math.atan2(\n          this.transform.controlPoints[1].y - position.y,\n          this.transform.controlPoints[1].x - position.x\n        ),\n        0,\n        2 * Math.PI\n      );\n    }\n    if (this.props.fill) {\n      this.offContext.fill();\n    }\n    if (this.props.outline || !this.props.fill) {\n      this.offContext.stroke();\n    }\n  }\n\n  getDimension(): Vector {\n    return new Vector(\n      Vector.Distance(\n        this.transform.controlPoints[1],\n        this.transform.controlPoints[3]\n      ),\n      Vector.Distance(\n        this.transform.controlPoints[0],\n        this.transform.controlPoints[2]\n      )\n    );\n  }\n}\n","import { Vector } from \"../math/vector\";\nimport { Node } from \"../core/node\";\n\nexport class Empty extends Node {\n  constructor(id: string, position: Vector) {\n    super(id, position, []);\n  }\n\n  _render(): void {\n    /**/\n  }\n  _offRender(): void {\n    /**/\n  }\n\n  getDimension(): Vector {\n    return Vector.Zero();\n  }\n}\n","import { Vector } from \"../math/vector\";\nimport { Node } from \"../core/node\";\n\nexport interface ImageOptions {\n  shadowColor?: string;\n  shadowOffset?: Vector;\n  staticShadow?: boolean;\n  shadowBlur?: number;\n}\n\nexport class Image extends Node {\n  _source: HTMLImageElement;\n\n  constructor(\n    id: string,\n    position: Vector,\n    source: string | HTMLImageElement,\n    public width: number,\n    public height: number,\n    public props?: ImageOptions\n  ) {\n    super(id, position, []);\n\n    !props && (this.props = {});\n    if (typeof source == \"string\") {\n      this._source = new window.Image();\n      this._source.src = source;\n    } else {\n      this._source = source;\n    }\n    this._source.crossOrigin = \"Anonymous\";\n  }\n\n  _render(): void {\n    if (this.props) {\n      this.props.shadowColor &&\n        (this.context.shadowColor = this.props.shadowColor);\n      this.props.shadowBlur &&\n        (this.context.shadowBlur = this.props.shadowBlur);\n      if (this.props.shadowOffset) {\n        if (!this.props.staticShadow) {\n          let shadowOffset = this.props.shadowOffset\n            .transform(this.transform.worldTransform)\n            .subtract(this.absolutePosition);\n          this.context.shadowOffsetX = shadowOffset.x;\n          this.context.shadowOffsetY = shadowOffset.y;\n        } else {\n          this.context.shadowOffsetX = this.props.shadowOffset.x;\n          this.context.shadowOffsetY = this.props.shadowOffset.y;\n        }\n      }\n    }\n\n    // Rotate image using worldTransform's rotation component\n    this.context.translate(this.absolutePosition.x, this.absolutePosition.y);\n    this.context.rotate(\n      this.transform.worldTransform.getRotation() * (Math.PI / 180)\n    );\n    this.context.translate(-this.absolutePosition.x, -this.absolutePosition.y);\n\n    let topLeft = this.absolutePosition.subtract(\n      (this.width * this.transform.scale.x) / 2,\n      (this.height * this.transform.scale.y) / 2\n    );\n    this.context.drawImage(\n      this._source,\n      topLeft.x,\n      topLeft.y,\n      this.width * this.transform.scale.x,\n      this.height * this.transform.scale.y\n    );\n  }\n\n  _offRender(): void {\n    this.offContext.fillStyle = this.hitColor;\n\n    // Rotate bounding-rectangle using worldTransform's rotation component\n    this.offContext.translate(this.absolutePosition.x, this.absolutePosition.y);\n    this.offContext.rotate(\n      this.transform.worldTransform.getRotation() * (Math.PI / 180)\n    );\n    this.offContext.translate(\n      -this.absolutePosition.x,\n      -this.absolutePosition.y\n    );\n\n    let topLeft = this.absolutePosition.subtract(\n      (this.width * this.transform.scale.x) / 2,\n      (this.height * this.transform.scale.y) / 2\n    );\n    this.offContext.fillRect(\n      topLeft.x,\n      topLeft.y,\n      this.width * this.transform.scale.x,\n      this.height * this.transform.scale.y\n    );\n  }\n\n  getDimension(): Vector {\n    return new Vector(this.width, this.height);\n  }\n}\n","export * from \"./ellipse\";\r\nexport * from \"./empty\";\r\nexport * from \"./image\";\r\nexport * from \"./line\";\r\nexport * from \"./polygon\";\r\nexport * from \"./rectangle\";\r\nexport * from \"./text\";\r\nexport * from \"./linear-gradient\";\r\nexport * from \"./radial-gradient\";\r\n","import { Vector } from \"../math/vector\";\nimport { LinearGradient, RadialGradient } from \".\";\nimport { Node } from \"../core/node\";\n\nexport interface LineOptions {\n  color?: string | LinearGradient | RadialGradient;\n  lineWidth?: number;\n  lineCap?: CanvasLineCap;\n  lineDashSegments?: number[];\n  shadowColor?: string;\n  shadowOffset?: Vector;\n  staticShadow?: boolean;\n  shadowBlur?: number;\n}\n\nexport class Line extends Node {\n  get from(): Vector {\n    if (this._from instanceof Node) return this._from.absolutePosition;\n    else return this.transform.controlPoints[0];\n  }\n  get to(): Vector {\n    if (this._to instanceof Node) return this._to.absolutePosition;\n    else return this.transform.controlPoints[1];\n  }\n\n  constructor(\n    id: string,\n    public _from: Vector | Node,\n    public _to: Vector | Node,\n    pivot?: number,\n    public props?: LineOptions\n  ) {\n    super(\n      id,\n      _from instanceof Vector && _to instanceof Vector\n        ? pivot\n          ? _from.add((_to.x - _from.x) * pivot, (_to.y - _from.y) * pivot)\n          : _from.clone()\n        : Vector.Zero(),\n      _from instanceof Vector && _to instanceof Vector ? [_from, _to] : []\n    );\n\n    !props && (this.props = {});\n    if (this.props.color && typeof this.props.color != \"string\") {\n      this.props.color.node = this;\n    }\n  }\n\n  _render(): void {\n    if (this.props) {\n      this.props.color &&\n        (this.context.strokeStyle =\n          typeof this.props.color == \"string\"\n            ? this.props.color\n            : this.props.color.create(this.context));\n      this.props.lineWidth && (this.context.lineWidth = this.props.lineWidth);\n      this.props.lineCap && (this.context.lineCap = this.props.lineCap);\n      this.props.lineDashSegments &&\n        this.context.setLineDash(this.props.lineDashSegments);\n      this.props.shadowColor &&\n        (this.context.shadowColor = this.props.shadowColor);\n      this.props.shadowBlur &&\n        (this.context.shadowBlur = this.props.shadowBlur);\n      if (this.props.shadowOffset) {\n        if (!this.props.staticShadow) {\n          let shadowOffset = this.props.shadowOffset\n            .transform(this.transform.worldTransform)\n            .subtract(this.absolutePosition);\n          this.context.shadowOffsetX = shadowOffset.x;\n          this.context.shadowOffsetY = shadowOffset.y;\n        } else {\n          this.context.shadowOffsetX = this.props.shadowOffset.x;\n          this.context.shadowOffsetY = this.props.shadowOffset.y;\n        }\n      }\n    }\n\n    this.context.beginPath();\n    this.context.moveTo(this.from.x, this.from.y);\n    this.context.lineTo(this.to.x, this.to.y);\n    this.context.stroke();\n  }\n\n  _offRender(): void {\n    this.props.lineWidth && (this.offContext.lineWidth = this.props.lineWidth);\n    this.offContext.strokeStyle = this.hitColor;\n\n    this.offContext.beginPath();\n    this.offContext.moveTo(this.from.x, this.from.y);\n    this.offContext.lineTo(this.to.x, this.to.y);\n    this.offContext.stroke();\n  }\n\n  getDimension(): Vector {\n    return new Vector(\n      Vector.Distance(\n        this.transform.controlPoints[0],\n        this.transform.controlPoints[1]\n      ),\n      0\n    );\n  }\n}\n","import { Constant, Handle } from \"../common\";\nimport { Node } from \"../core/node\";\nimport { Vector } from \"../math/vector\";\n\nexport class LinearGradient {\n  node: Node;\n\n  constructor(\n    public offset: Vector,\n    public degrees: number,\n    public length: number | Handle,\n    public colors: string[],\n    public weights: number[]\n  ) {}\n\n  create(context: CanvasRenderingContext2D): CanvasGradient {\n    let gradient: CanvasGradient,\n      from,\n      to,\n      length,\n      delta = new Vector(0, 0);\n\n    length =\n      this.length == Handle.AUTO ? this.node.getDimension().max() : this.length;\n    delta.x = (length / 2) * Math.cos(this.degrees * Constant.TAU);\n    delta.y = (length / 2) * Math.sin(this.degrees * Constant.TAU);\n\n    from = this.offset\n      .subtract(delta)\n      .transform(this.node.transform.worldTransform);\n    to = this.offset.add(delta).transform(this.node.transform.worldTransform);\n\n    gradient = context.createLinearGradient(from.x, from.y, to.x, to.y);\n    this.colors.forEach((color, index) => {\n      gradient.addColorStop(this.weights[index], color);\n    });\n    return gradient;\n  }\n}\n","import { Vector } from \"../math/vector\";\nimport { LinearGradient, RadialGradient } from \".\";\nimport { Node } from \"../core/node\";\nimport { Handle } from \"../common/enums\";\n\nexport interface PolygonOptions {\n  outline?: boolean;\n  fill?: boolean;\n  outlineColor?: string | LinearGradient | RadialGradient;\n  fillColor?: string | LinearGradient | RadialGradient;\n  outlineWidth?: number;\n  outlineDashSegments?: number[];\n  shadowColor?: string;\n  shadowOffset?: Vector;\n  staticShadow?: boolean;\n  shadowBlur?: number;\n}\n\nexport class Polygon extends Node {\n  constructor(\n    id: string,\n    vertices: Vector[],\n    center: Vector | Handle,\n    public props?: PolygonOptions\n  ) {\n    super(\n      id,\n      center instanceof Vector ? center : Vector.Average(vertices),\n      vertices\n    );\n\n    !props && (this.props = {});\n    if (this.props.outlineColor && typeof this.props.outlineColor != \"string\") {\n      this.props.outlineColor.node = this;\n    }\n    if (this.props.fillColor && typeof this.props.fillColor != \"string\") {\n      this.props.fillColor.node = this;\n    }\n  }\n\n  _render(): void {\n    if (this.props) {\n      this.props.outlineColor &&\n        (this.context.strokeStyle =\n          typeof this.props.outlineColor == \"string\"\n            ? this.props.outlineColor\n            : this.props.outlineColor.create(this.context));\n      this.props.fillColor &&\n        (this.context.fillStyle =\n          typeof this.props.fillColor == \"string\"\n            ? this.props.fillColor\n            : this.props.fillColor.create(this.context));\n      this.props.outlineWidth &&\n        (this.context.lineWidth = this.props.outlineWidth);\n      this.props.outlineDashSegments &&\n        this.context.setLineDash(this.props.outlineDashSegments);\n      this.props.shadowColor &&\n        (this.context.shadowColor = this.props.shadowColor);\n      this.props.shadowBlur &&\n        (this.context.shadowBlur = this.props.shadowBlur);\n      if (this.props.shadowOffset) {\n        if (!this.props.staticShadow) {\n          let shadowOffset = this.props.shadowOffset\n            .transform(this.transform.worldTransform)\n            .subtract(this.absolutePosition);\n          this.context.shadowOffsetX = shadowOffset.x;\n          this.context.shadowOffsetY = shadowOffset.y;\n        } else {\n          this.context.shadowOffsetX = this.props.shadowOffset.x;\n          this.context.shadowOffsetY = this.props.shadowOffset.y;\n        }\n      }\n    }\n\n    this.context.beginPath();\n    this.context.moveTo(\n      this.transform.controlPoints[0].x,\n      this.transform.controlPoints[0].y\n    );\n    for (let index = 1; index < this.transform.controlPoints.length; index++) {\n      this.context.lineTo(\n        this.transform.controlPoints[index].x,\n        this.transform.controlPoints[index].y\n      );\n    }\n    this.context.closePath();\n\n    if (this.props.fill) {\n      this.context.fill();\n    }\n    if (this.props.outline || !this.props.fill) {\n      this.context.stroke();\n    }\n  }\n\n  _offRender(): void {\n    this.props.outlineWidth &&\n      (this.offContext.lineWidth = this.props.outlineWidth);\n    this.offContext.strokeStyle = this.hitColor;\n    this.offContext.fillStyle = this.hitColor;\n\n    this.offContext.beginPath();\n    this.offContext.moveTo(\n      this.transform.controlPoints[0].x,\n      this.transform.controlPoints[0].y\n    );\n    for (let index = 1; index < this.transform.controlPoints.length; index++) {\n      this.offContext.lineTo(\n        this.transform.controlPoints[index].x,\n        this.transform.controlPoints[index].y\n      );\n    }\n    this.offContext.closePath();\n\n    if (this.props.fill) {\n      this.offContext.fill();\n    }\n    if (this.props.outline || !this.props.fill) {\n      this.offContext.stroke();\n    }\n  }\n\n  getDimension(): Vector {\n    let bounds = Vector.Bounds(this.transform.controlPoints);\n\n    return new Vector(\n      Math.abs(bounds[0].x - bounds[1].x),\n      Math.abs(bounds[0].y - bounds[1].y)\n    );\n  }\n}\n","import { Vector } from \"../math/vector\";\nimport { Handle } from \"../common/enums\";\nimport { Node } from \"../core/node\";\n\nexport class RadialGradient {\n  node: Node;\n\n  constructor(\n    public fromOffset: Vector,\n    public fromRadius: number | Handle,\n    public toOffset: Vector,\n    public toRadius: number | Handle,\n    public colors: string[],\n    public weights: number[]\n  ) {}\n\n  create(context: CanvasRenderingContext2D): CanvasGradient {\n    let gradient: CanvasGradient;\n    let fromCenter = this.fromOffset.transform(\n      this.node.transform.worldTransform\n    );\n    let toCenter = this.toOffset.transform(this.node.transform.worldTransform);\n    let fromRadius, toRadius;\n    if (this.fromRadius == Handle.AUTO || this.toRadius == Handle.AUTO) {\n      fromRadius = 1;\n      toRadius = this.node.getDimension().max() / 2;\n    } else {\n      fromRadius = this.fromRadius;\n      toRadius = this.toRadius;\n    }\n\n    gradient = context.createRadialGradient(\n      fromCenter.x,\n      fromCenter.y,\n      fromRadius,\n      toCenter.x,\n      toCenter.y,\n      toRadius\n    );\n    this.colors.forEach((color, index) => {\n      gradient.addColorStop(this.weights[index], color);\n    });\n    return gradient;\n  }\n}\n","import { Vector } from \"../math/vector\";\nimport { LinearGradient, RadialGradient } from \".\";\nimport { Node } from \"../core/node\";\n\nexport interface RectangleOptions {\n  outline?: boolean;\n  fill?: boolean;\n  outlineColor?: string | LinearGradient | RadialGradient;\n  fillColor?: string | LinearGradient | RadialGradient;\n  outlineWidth?: number;\n  outlineDashSegments?: number[];\n  shadowColor?: string;\n  shadowOffset?: Vector;\n  staticShadow?: boolean;\n  shadowBlur?: number;\n}\n\nexport class Rectangle extends Node {\n  constructor(\n    id: string,\n    position: Vector,\n    width: number,\n    height: number,\n    public props?: RectangleOptions\n  ) {\n    super(id, position, [\n      position.add(-width / 2, -height / 2),\n      position.add(width / 2, -height / 2),\n      position.add(width / 2, height / 2),\n      position.add(-width / 2, height / 2),\n    ]);\n\n    !props && (this.props = {});\n    if (this.props.outlineColor && typeof this.props.outlineColor != \"string\") {\n      this.props.outlineColor.node = this;\n    }\n    if (this.props.fillColor && typeof this.props.fillColor != \"string\") {\n      this.props.fillColor.node = this;\n    }\n  }\n\n  _render(): void {\n    if (this.props) {\n      this.props.outlineColor &&\n        (this.context.strokeStyle =\n          typeof this.props.outlineColor == \"string\"\n            ? this.props.outlineColor\n            : this.props.outlineColor.create(this.context));\n      this.props.fillColor &&\n        (this.context.fillStyle =\n          typeof this.props.fillColor == \"string\"\n            ? this.props.fillColor\n            : this.props.fillColor.create(this.context));\n      this.props.outlineWidth &&\n        (this.context.lineWidth = this.props.outlineWidth);\n      this.props.outlineDashSegments &&\n        this.context.setLineDash(this.props.outlineDashSegments);\n      this.props.shadowColor &&\n        (this.context.shadowColor = this.props.shadowColor);\n      this.props.shadowBlur &&\n        (this.context.shadowBlur = this.props.shadowBlur);\n      if (this.props.shadowOffset) {\n        if (!this.props.staticShadow) {\n          let shadowOffset = this.props.shadowOffset\n            .transform(this.transform.worldTransform)\n            .subtract(this.absolutePosition);\n          this.context.shadowOffsetX = shadowOffset.x;\n          this.context.shadowOffsetY = shadowOffset.y;\n        } else {\n          this.context.shadowOffsetX = this.props.shadowOffset.x;\n          this.context.shadowOffsetY = this.props.shadowOffset.y;\n        }\n      }\n    }\n\n    this.context.beginPath();\n    this.context.moveTo(\n      this.transform.controlPoints[0].x,\n      this.transform.controlPoints[0].y\n    );\n    this.context.lineTo(\n      this.transform.controlPoints[1].x,\n      this.transform.controlPoints[1].y\n    );\n    this.context.lineTo(\n      this.transform.controlPoints[2].x,\n      this.transform.controlPoints[2].y\n    );\n    this.context.lineTo(\n      this.transform.controlPoints[3].x,\n      this.transform.controlPoints[3].y\n    );\n    this.context.lineTo(\n      this.transform.controlPoints[0].x,\n      this.transform.controlPoints[0].y\n    );\n    if (this.props.fill) {\n      this.context.fill();\n    }\n    if (this.props.outline || !this.props.fill) {\n      this.context.stroke();\n    }\n  }\n\n  _offRender(): void {\n    this.props.outlineWidth &&\n      (this.offContext.lineWidth = this.props.outlineWidth);\n    this.offContext.strokeStyle = this.hitColor;\n    this.offContext.fillStyle = this.hitColor;\n\n    this.offContext.beginPath();\n    this.offContext.moveTo(\n      this.transform.controlPoints[0].x,\n      this.transform.controlPoints[0].y\n    );\n    this.offContext.lineTo(\n      this.transform.controlPoints[1].x,\n      this.transform.controlPoints[1].y\n    );\n    this.offContext.lineTo(\n      this.transform.controlPoints[2].x,\n      this.transform.controlPoints[2].y\n    );\n    this.offContext.lineTo(\n      this.transform.controlPoints[3].x,\n      this.transform.controlPoints[3].y\n    );\n    this.offContext.lineTo(\n      this.transform.controlPoints[0].x,\n      this.transform.controlPoints[0].y\n    );\n    if (this.props.fill) {\n      this.offContext.fill();\n    }\n    if (this.props.outline || !this.props.fill) {\n      this.offContext.stroke();\n    }\n  }\n\n  getDimension(): Vector {\n    return new Vector(\n      Vector.Distance(\n        this.transform.controlPoints[0],\n        this.transform.controlPoints[1]\n      ),\n      Vector.Distance(\n        this.transform.controlPoints[1],\n        this.transform.controlPoints[2]\n      )\n    );\n  }\n}\n","import { Vector } from \"../math/vector\";\nimport { LinearGradient, RadialGradient } from \".\";\nimport { Node } from \"../core/node\";\n\nexport interface TextOptions {\n  font?: string;\n  outline?: boolean;\n  fill?: boolean;\n  outlineColor?: string | LinearGradient | RadialGradient;\n  fillColor?: string | LinearGradient | RadialGradient;\n  outlineWidth?: number;\n  shadowColor?: string;\n  shadowOffset?: Vector;\n  staticShadow?: boolean;\n  shadowBlur?: number;\n}\n\nexport class Text extends Node {\n  _text: string;\n  _originalWidth: number;\n  _originalHeight: number;\n\n  get text(): string {\n    return this._text;\n  }\n  set text(text: string) {\n    this._text = text;\n  }\n\n  constructor(\n    id: string,\n    position: Vector,\n    text: string,\n    public props?: TextOptions\n  ) {\n    super(id, position, []);\n\n    !props && (this.props = {});\n    this.text = text;\n    if (this.props.outlineColor && typeof this.props.outlineColor != \"string\") {\n      this.props.outlineColor.node = this;\n    }\n    if (this.props.fillColor && typeof this.props.fillColor != \"string\") {\n      this.props.fillColor.node = this;\n    }\n\n    let textMetricContext = document.createElement(\"canvas\").getContext(\"2d\");\n    this.props.font && (textMetricContext.font = this.props.font);\n    this._originalWidth = textMetricContext.measureText(text).width;\n    this._originalHeight = textMetricContext.measureText(\"M\").width;\n  }\n\n  _render(): void {\n    if (this.props) {\n      this.props.outlineColor &&\n        (this.context.strokeStyle =\n          typeof this.props.outlineColor == \"string\"\n            ? this.props.outlineColor\n            : this.props.outlineColor.create(this.context));\n      this.props.fillColor &&\n        (this.context.fillStyle =\n          typeof this.props.fillColor == \"string\"\n            ? this.props.fillColor\n            : this.props.fillColor.create(this.context));\n      this.props.outlineWidth &&\n        (this.context.lineWidth = this.props.outlineWidth);\n      this.props.shadowColor &&\n        (this.context.shadowColor = this.props.shadowColor);\n      this.props.shadowBlur &&\n        (this.context.shadowBlur = this.props.shadowBlur);\n      if (this.props.shadowOffset) {\n        if (!this.props.staticShadow) {\n          let shadowOffset = this.props.shadowOffset\n            .transform(this.transform.worldTransform)\n            .subtract(this.absolutePosition);\n          this.context.shadowOffsetX = shadowOffset.x;\n          this.context.shadowOffsetY = shadowOffset.y;\n        } else {\n          this.context.shadowOffsetX = this.props.shadowOffset.x;\n          this.context.shadowOffsetY = this.props.shadowOffset.y;\n        }\n      }\n      this.props.font && (this.context.font = this.props.font);\n    }\n\n    // Rotate image using worldTransform's rotation component\n    this.context.translate(this.absolutePosition.x, this.absolutePosition.y);\n    this.context.scale(this.scale.x, this.scale.y);\n    this.context.rotate(\n      this.transform.worldTransform.getRotation() * (Math.PI / 180)\n    );\n    this.context.translate(-this.absolutePosition.x, -this.absolutePosition.y);\n\n    this.props.outline &&\n      this.context.strokeText(\n        this.text,\n        this.absolutePosition.x - this._originalWidth / 2,\n        this.absolutePosition.y + this._originalHeight / 2\n      );\n    (this.props.fill || !this.props.outline) &&\n      this.context.fillText(\n        this.text,\n        this.absolutePosition.x - this._originalWidth / 2,\n        this.absolutePosition.y + this._originalHeight / 2\n      );\n  }\n\n  _offRender(): void {\n    this.offContext.fillStyle = this.hitColor;\n\n    // Rotate image using worldTransform's rotation component\n    this.offContext.translate(this.absolutePosition.x, this.absolutePosition.y);\n    this.offContext.scale(this.scale.x, this.scale.y);\n    this.offContext.rotate(\n      this.transform.worldTransform.getRotation() * (Math.PI / 180)\n    );\n    this.offContext.translate(\n      -this.absolutePosition.x,\n      -this.absolutePosition.y\n    );\n\n    this.offContext.fillRect(\n      this.absolutePosition.x - this._originalWidth / 2,\n      this.absolutePosition.y - this._originalHeight / 2,\n      this._originalWidth,\n      this._originalHeight\n    );\n  }\n\n  getDimension(): Vector {\n    return new Vector(\n      Vector.Distance(\n        this.transform.controlPoints[0],\n        this.transform.controlPoints[1]\n      ),\n      0\n    );\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(229);\n"],"names":["root","factory","exports","module","define","amd","self","Constant","Math","PI","Handle","element","width","height","frameId","HTMLDivElement","this","canvasElement","document","createElement","clientWidth","clientHeight","appendChild","body","context","getContext","OffscreenCanvas","offCanvasElement","offContext","draw","drawing","stop","render","window","cancelAnimationFrame","requestAnimationFrame","bind","Canvas","Random","floor","random","toString","rgbToHex","rgb","Color","_componentToHex","c","hex","length","debugPoint","key","point","props","frames","Debug","limitDebugCalls","debugCalls","push","debugFunction","_debugPoint","arguments","canvas","clone","center","fillStyle","color","beginPath","arc","x","y","radius","fill","debugLine","from","to","_debugLine","strokeStyle","lineWidth","moveTo","lineTo","stroke","show","debug","call","save","restore","shift","globalUpdate","rootNode","Empty","Vector","Zero","sceneGraph","mousePos","colorToNode","_registerEvents","currentHitNode","prevHitNode","canvasOffset","currentDragNode","onmousemove","ev","getBoundingClientRect","clientX","left","clientY","top","_getHitNode","onmousedown","hitNode","onmouseup","onclick","oncontextmenu","preventDefault","position","getImageData","data","clearRect","transform","childs","forEach","child","updateWorldTransform","node","add","Node","parent","setContext","setDrawing","setHitColor","cNode","remove","nodeOrID","id","currentNode","queue","splice","indexOf","_debugSceneGraph","indent","console","log","order","Drawing","controlPoints","Transform","Unit","registeredEvents","zIndex","sort","a","b","newParent","map","absolutePosition","rotation","degrees","localRotation","scale","hitColor","on","eventKey","callback","_render","offRender","_offRender","method","args","dispose","max","Dimension","value","_multiply","another","result","Matrix","Array","i","j","sum","k","multiply","multiplyInPlace","getRotation","atan2","Identity","Multiply","matrix1","matrix2","_position","_localRotation","_rotation","_scale","_parent","localTrasform","worldTransform","refControlPoints","relativeControlPoints","index","newPosition","newRotation","newScale","controlPoint","subtract","applyTransform","_updateWorldTransform","parentWorldTransform","cos","sin","TAU","toFixed","arg1","arg2","addInPlace","subtractInPlace","rotate","pivot","cosT","sinT","rotateInPlace","tmpX","tmpY","matrix","transformInPlace","Midpoint","vector1","vector2","Distance","sqrt","pow","Bounds","vectors","minVec","Number","MAX_SAFE_INTEGER","maxVec","MIN_SAFE_INTEGER","vector","Average","sumX","sumY","minXOrCanvas","maxX","minY","maxY","Lerp","start","end","amount","minor","major","outlineColor","fillColor","create","outlineWidth","outlineDashSegments","setLineDash","shadowColor","shadowBlur","shadowOffset","staticShadow","shadowOffsetX","shadowOffsetY","ellipse","outline","getDimension","Ellipse","source","_source","Image","src","crossOrigin","translate","topLeft","drawImage","fillRect","_from","_to","lineCap","lineDashSegments","Line","offset","colors","weights","gradient","delta","AUTO","createLinearGradient","addColorStop","LinearGradient","vertices","closePath","bounds","abs","Polygon","fromOffset","fromRadius","toOffset","toRadius","fromCenter","toCenter","createRadialGradient","RadialGradient","Rectangle","text","textMetricContext","font","_originalWidth","measureText","_originalHeight","_text","strokeText","fillText","Text","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__"],"sourceRoot":""}