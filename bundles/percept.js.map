{"version":3,"file":"percept.js","mappings":"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","sources":["webpack://Percept/webpack/universalModuleDefinition","webpack://Percept/./src/common/constants.ts","webpack://Percept/./src/common/enums.ts","webpack://Percept/./src/common/index.ts","webpack://Percept/./src/core/canvas.ts","webpack://Percept/./src/core/color.ts","webpack://Percept/./src/core/debug.ts","webpack://Percept/./src/core/drawing.ts","webpack://Percept/./src/core/index.ts","webpack://Percept/./src/core/node.ts","webpack://Percept/./src/math/dimension.ts","webpack://Percept/./src/math/index.ts","webpack://Percept/./src/math/matrix.ts","webpack://Percept/./src/math/transform.ts","webpack://Percept/./src/math/vector.ts","webpack://Percept/./src/percept.ts","webpack://Percept/./src/view/ellipse.ts","webpack://Percept/./src/view/empty.ts","webpack://Percept/./src/view/image.ts","webpack://Percept/./src/view/index.ts","webpack://Percept/./src/view/line.ts","webpack://Percept/./src/view/linear-gradient.ts","webpack://Percept/./src/view/polygon.ts","webpack://Percept/./src/view/radial-gradient.ts","webpack://Percept/./src/view/rectangle.ts","webpack://Percept/./src/view/text.ts","webpack://Percept/webpack/bootstrap","webpack://Percept/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Percept\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Percept\"] = factory();\n\telse\n\t\troot[\"Percept\"] = factory();\n})(self, () => {\nreturn ","export enum Constant {\r\n  TAU = Math.PI / 180,\r\n}\r\n","export enum Handle {\r\n  AUTO = -1,\r\n}\r\n","export * from \"./enums\";\r\nexport * from \"./constants\";\r\n","import { Drawing } from \"./drawing\";\r\n\r\n/**\r\n * The Canvas object holds an HTMLCanvasElement reference and its 2d context\r\n */\r\nexport class Canvas {\r\n  canvasElement: HTMLCanvasElement;\r\n  context: CanvasRenderingContext2D;\r\n  offCanvasElement: OffscreenCanvas | HTMLCanvasElement;\r\n  offContext: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D;\r\n\r\n  width: number;\r\n  height: number;\r\n  private frameId: number = 0;\r\n\r\n  /**\r\n   * If no parameters are passed then a new canvas element will be created and appended to `<body>`\r\n   *\r\n   * @param element Reference to an html `<canvas>` or `<div>` element, if a `<div>` element is passed, then a canvas will be created and appended\r\n   * @param width Passing a width will overwrite previously defined canvas width\r\n   * @param height Passing a height will overwrite previously defined canvas height\r\n   */\r\n  constructor(\r\n    element?: HTMLCanvasElement | HTMLDivElement,\r\n    width?: number,\r\n    height?: number\r\n  ) {\r\n    if (!element) {\r\n      this.canvasElement = document.createElement(\"canvas\");\r\n      this.canvasElement.width = document.body.clientWidth;\r\n      this.canvasElement.height = document.body.clientHeight;\r\n      document.body.appendChild(this.canvasElement);\r\n    } else {\r\n      if (element instanceof HTMLDivElement) {\r\n        this.canvasElement = document.createElement(\"canvas\");\r\n        if (width && height) {\r\n          this.canvasElement.width = width;\r\n          this.canvasElement.height = height;\r\n        } else {\r\n          this.canvasElement.width = element.clientWidth;\r\n          this.canvasElement.height = element.clientHeight;\r\n        }\r\n        element.appendChild(this.canvasElement);\r\n      } else {\r\n        this.canvasElement = element;\r\n        if (width && height) {\r\n          this.canvasElement.width = width;\r\n          this.canvasElement.height = height;\r\n        }\r\n      }\r\n    }\r\n    this.width = this.canvasElement.width;\r\n    this.height = this.canvasElement.height;\r\n    this.context = this.canvasElement.getContext(\"2d\");\r\n\r\n    if (typeof OffscreenCanvas !== \"undefined\") {\r\n      this.offCanvasElement = new OffscreenCanvas(this.width, this.height);\r\n      this.offContext = this.offCanvasElement.getContext(\"2d\");\r\n    } else {\r\n      this.offCanvasElement = document.createElement(\"canvas\");\r\n      this.offCanvasElement.width = this.width;\r\n      this.offCanvasElement.height = this.height;\r\n      this.offContext = this.offCanvasElement.getContext(\"2d\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calls render function of `Drawing`\r\n   *\r\n   * @param drawing A `Drawing` object, which will be rendered by this canvas\r\n   */\r\n  draw(drawing: Drawing) {\r\n    this.stop();\r\n    this.render(drawing);\r\n  }\r\n\r\n  /**\r\n   * Stops rendering current Drawing\r\n   */\r\n  stop() {\r\n    window.cancelAnimationFrame(this.frameId);\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  private render(drawing: Drawing) {\r\n    drawing.render();\r\n    if (this.frameId < 0) return;\r\n    this.frameId = window.requestAnimationFrame(\r\n      this.render.bind(this, drawing)\r\n    );\r\n  }\r\n}\r\n","export class Color {\r\n  static Random(): string {\r\n    return \"#\" + Math.floor(Math.random() * 16777215).toString(16);\r\n  }\r\n\r\n  static rgbToHex(rgb: number[] | Uint8ClampedArray): string {\r\n    return (\r\n      \"#\" +\r\n      Color._componentToHex(rgb[0]) +\r\n      Color._componentToHex(rgb[1]) +\r\n      Color._componentToHex(rgb[2])\r\n    );\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  private static _componentToHex(c: number) {\r\n    let hex = c.toString(16);\r\n    return hex.length == 1 ? \"0\" + hex : hex;\r\n  }\r\n}\r\n","import { Drawing, DebugCall } from \".\";\nimport { Vector } from \"../math/vector\";\n\n/**\n * Includes static methods for debugging\n */\nexport class Debug {\n  /**\n   * Will render a filled circle denoting a single point on canvas\n   *\n   * @param key A unique name for this debug\n   * @param drawing Drawing, on which this debug will render\n   * @param point The point to render\n   * @param props Styling properties for debug\n   * @param frames Specifies for how many frames this debug will persist (e.g passing 100 will allow this debug to be rendered for 100 consecutive frames without clearing it from canvas)\n   */\n  static debugPoint(\n    key: string,\n    drawing: Drawing,\n    point: Vector,\n    props: { color: string; radius?: number },\n    frames?: number\n  ) {\n    Debug.limitDebugCalls(drawing, key, frames);\n\n    drawing.debugCalls[key].push({\n      debugFunction: Debug._debugPoint,\n      arguments: [drawing.canvas.context, point.clone(), props],\n    });\n  }\n\n  /* istanbul ignore next */\n  private static _debugPoint(\n    context: CanvasRenderingContext2D,\n    center: Vector,\n    props: { color: string; radius?: number }\n  ) {\n    context.fillStyle = props.color;\n    context.beginPath();\n    context.arc(\n      center.x,\n      center.y,\n      props.radius ? props.radius : 2,\n      0,\n      2 * Math.PI\n    );\n    context.fill();\n  }\n\n  /**\n   * Will render a line with green and red dots on start and end co-ordinates of line\n   *\n   * @param key A unique name for this debug\n   * @param drawing Drawing, on which this debug will render\n   * @param from Start Vector for this line\n   * @param to End Vector point for this line\n   * @param props Styling properties for debug\n   * @param frames Specifies for how many frames this debug will persist (e.g passing 100 will allow this debug to be rendered for 100 consecutive frames without clearing it from canvas)\n   */\n  static debugLine(\n    key: string,\n    drawing: Drawing,\n    from: Vector,\n    to: Vector,\n    props: { color: string; width?: number },\n    frames?: number\n  ) {\n    Debug.limitDebugCalls(drawing, key, frames);\n\n    drawing.debugCalls[key].push({\n      debugFunction: Debug._debugLine,\n      arguments: [drawing.canvas.context, from.clone(), to.clone(), props],\n    });\n  }\n\n  /* istanbul ignore next */\n  private static _debugLine(\n    context: CanvasRenderingContext2D,\n    from: Vector,\n    to: Vector,\n    props: { color: string; width?: number }\n  ) {\n    context.strokeStyle = props.color;\n    context.lineWidth = props.width ? props.width : 1;\n    context.beginPath();\n    context.moveTo(from.x, from.y);\n    context.lineTo(to.x, to.y);\n    context.stroke();\n\n    context.fillStyle = \"green\";\n    context.beginPath();\n    context.arc(from.x, from.y, 2, 0, 2 * Math.PI);\n    context.fill();\n\n    context.fillStyle = \"red\";\n    context.beginPath();\n    context.arc(to.x, to.y, 2, 0, 2 * Math.PI);\n    context.fill();\n  }\n\n  /**\n   * @hidden\n   *\n   * Starts debug render calls stored in debugCalls\n   */\n  static show(\n    debugCalls: Record<string, DebugCall[]>,\n    context: CanvasRenderingContext2D\n  ) {\n    for (let debug in debugCalls) {\n      for (let call of debugCalls[debug]) {\n        context.save();\n        call.debugFunction(...call.arguments);\n        context.restore();\n      }\n    }\n  }\n\n  // Used for persisting the debug calls on canvas (shifts array of debug calls to limit array size to frames)\n  /* istanbul ignore next */\n  private static limitDebugCalls(\n    drawing: Drawing,\n    key: string,\n    frames: number\n  ) {\n    if (\n      frames &&\n      drawing.debugCalls[key] &&\n      frames - 1 < drawing.debugCalls[key].length\n    ) {\n      drawing.debugCalls[key].shift();\n    } else {\n      (!drawing.debugCalls[key] || !frames) && (drawing.debugCalls[key] = []);\n    }\n  }\n}\n","import { Canvas, Debug, Node, Color } from \".\";\nimport { Vector } from \"../math/vector\";\nimport { Empty } from \"../view/empty\";\n\nexport interface DebugCall {\n  debugFunction: Function;\n  arguments: any[];\n  frames?: number;\n}\n\n/**\n * Stores all views which will be rendered by canvas\n */\nexport class Drawing {\n  // Scene-graph root node\n  private sceneGraph: Node;\n  /**@hidden */\n  debugCalls: Record<string, DebugCall[]>;\n\n  colorToNode: { [key: string]: Node };\n  pointers: any[] = [];\n\n  /**\n   *\n   * @param canvas The Canvas object\n   * @param globalUpdate A function that will be called per frame\n   */\n  constructor(public canvas: Canvas, public globalUpdate?: Function) {\n    let rootNode = new Empty(\"#Root\", Vector.Zero());\n    rootNode.context = this.canvas.context;\n    rootNode.drawing = this;\n    this.sceneGraph = rootNode;\n    this.debugCalls = {};\n\n    this.colorToNode = {};\n    this._registerEvents();\n  }\n\n  private getRelativePosition(ev: PointerEvent | WheelEvent | MouseEvent) {\n    const canvasOffset = this.canvas.canvasElement.getBoundingClientRect();\n    return new Vector(\n      ev.clientX - canvasOffset.left,\n      ev.clientY - canvasOffset.top\n    );\n  }\n\n  private updatePointer(ev: PointerEvent, position: Vector) {\n    let pointer = this.pointers.find((pntr) => pntr.id === ev.pointerId);\n    if (pointer) {\n      pointer.position = position;\n    }\n  }\n\n  private removePointer(ev: PointerEvent) {\n    this.pointers.splice(\n      this.pointers.findIndex((pointer) => pointer.id === ev.pointerId),\n      1\n    );\n  }\n\n  /* istanbul ignore next */\n  private _registerEvents(): void {\n    let currHitNode: Node, prevHitNode: Node;\n\n    this.canvas.canvasElement.onpointerdown = (ev: PointerEvent) => {\n      this.pointers.push({\n        id: ev.pointerId,\n        position: this.getRelativePosition(ev),\n      });\n\n      if (this.pointers.length === 1) {\n        currHitNode = this._getHitNode(this.pointers[0].position);\n        currHitNode &&\n          currHitNode.call(\"down\", [this.pointers[0].position.clone()]);\n      } else {\n        currHitNode = null;\n      }\n    };\n\n    this.canvas.canvasElement.onpointermove = (ev: PointerEvent) => {\n      const position = this.getRelativePosition(ev);\n      this.updatePointer(ev, position);\n\n      currHitNode && currHitNode.call(\"drag\", [position.clone()]);\n\n      if (ev.pointerType === \"mouse\" && !currHitNode) {\n        let hitNode = this._getHitNode(position);\n        if (hitNode !== prevHitNode) {\n          prevHitNode && prevHitNode.call(\"exit\", [position.clone()]);\n          hitNode && hitNode.call(\"enter\", [position.clone()]);\n        } else {\n          hitNode && !currHitNode && hitNode.call(\"over\", [position.clone()]);\n        }\n        prevHitNode = hitNode;\n      }\n    };\n\n    this.canvas.canvasElement.onpointerup = (ev: PointerEvent) => {\n      this.removePointer(ev);\n\n      currHitNode = null;\n\n      const position = this.getRelativePosition(ev);\n      let hitNode = this._getHitNode(position);\n      hitNode && hitNode.call(\"up\", [position.clone()]);\n    };\n\n    this.canvas.canvasElement.onpointerout = (ev) => {\n      this.removePointer(ev);\n\n      if (this.pointers.length === 0) {\n        currHitNode = null;\n      }\n      if (prevHitNode) {\n        const position = this.getRelativePosition(ev);\n        prevHitNode.call(\"exit\", [position.clone()]);\n        prevHitNode = null;\n      }\n    };\n\n    this.canvas.canvasElement.onclick = (ev) => {\n      const position = this.getRelativePosition(ev);\n      let hitNode = this._getHitNode(position);\n      hitNode && hitNode.call(\"click\", [position.clone()]);\n    };\n\n    this.canvas.canvasElement.oncontextmenu = (ev) => {\n      ev.preventDefault();\n\n      let hitNode = this._getHitNode(this.getRelativePosition(ev));\n      hitNode && hitNode.call(\"rightclick\");\n    };\n  }\n\n  /* istanbul ignore next */\n  private _getHitNode(position: Vector): Node {\n    return this.colorToNode[\n      Color.rgbToHex(\n        this.canvas.offContext.getImageData(position.x, position.y, 1, 1).data\n      )\n    ];\n  }\n\n  /** @hidden */\n  render() {\n    this.canvas.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    this.canvas.offContext.clearRect(\n      0,\n      0,\n      this.canvas.width,\n      this.canvas.height\n    );\n\n    this.sceneGraph.call(\"update\");\n\n    this.globalUpdate && this.globalUpdate();\n\n    this.sceneGraph.transform.childs.forEach((child) => {\n      child.updateWorldTransform();\n    });\n\n    this.sceneGraph.transform.childs.forEach((child) => {\n      child.node.render();\n    });\n\n    Debug.show(this.debugCalls, this.canvas.context);\n  }\n\n  /**\n   * Adds a view object to this drawing\n   *\n   * @param node A View object to be rendered\n   */\n  add(node: Node | Node[]): void {\n    if (node instanceof Node) {\n      node.parent = this.sceneGraph;\n      node.setContext(this.canvas.context, this.canvas.offContext);\n      node.setDrawing(this);\n      node.setHitColor();\n    } else {\n      node.forEach((cNode) => {\n        cNode.parent = this.sceneGraph;\n        cNode.setContext(this.canvas.context, this.canvas.offContext);\n        cNode.setDrawing(this);\n        cNode.setHitColor();\n      });\n    }\n  }\n\n  /**\n   * Removes a view object from this drawing\n   *\n   * @param nodeOrID A View object or its id\n   */\n  remove(nodeOrID: Node | string) {\n    if (nodeOrID instanceof Node) nodeOrID = nodeOrID.id;\n\n    let queue = [];\n    let currentNode;\n    queue.push(this.sceneGraph);\n\n    while ((currentNode = queue.shift())) {\n      if (currentNode.id == nodeOrID) {\n        currentNode.transform.parent.childs.splice(\n          currentNode.transform.parent.childs.indexOf(currentNode.transform),\n          1\n        );\n      } else {\n        currentNode.transform.childs.forEach((child) => {\n          queue.push(child.node);\n        });\n      }\n    }\n  }\n\n  /* istanbul ignore next */\n  private _debugSceneGraph(root: Node, indent: string): void {\n    console.log(indent + root.id + \"[\" + root.order + \"]\");\n\n    root.transform.childs.forEach((child) => {\n      this._debugSceneGraph(child.node, \" \" + indent);\n    });\n  }\n}\n","export * from \"./canvas\";\r\nexport * from \"./color\";\r\nexport * from \"./debug\";\r\nexport * from \"./drawing\";\r\nexport * from \"./event\";\r\nexport * from \"./node\";\r\n","import { Transform, Vector } from \"../math\";\nimport { Drawing } from \"./drawing\";\nimport { Event } from \"./event\";\nimport { Color } from \"./color\";\n\nexport abstract class Node implements Event {\n  drawing: Drawing;\n  context: CanvasRenderingContext2D;\n  offContext: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D;\n  transform: Transform;\n  registeredEvents: any;\n  order: number;\n  hitColor: string;\n\n  abstract _render(): void;\n  abstract _offRender(): void;\n  abstract getDimension(): Vector;\n\n  get zIndex(): number {\n    return this.order;\n  }\n  set zIndex(zIndex: number) {\n    this.order = zIndex;\n\n    if (this.parent) {\n      this.parent.transform.childs.sort((a, b) => {\n        return a.node.order - b.node.order;\n      });\n    }\n  }\n\n  get parent(): Node {\n    return this.transform.parent.node;\n  }\n  set parent(newParent: Node) {\n    this.transform.parent = newParent.transform;\n  }\n\n  get childs(): Node[] {\n    return this.transform.childs.map((child) => {\n      return child.node;\n    });\n  }\n\n  get position(): Vector {\n    return this.transform.position;\n  }\n  set position(position: Vector) {\n    this.transform.position = position;\n  }\n  get absolutePosition(): Vector {\n    return this.transform.absolutePosition;\n  }\n\n  get rotation(): number {\n    return this.transform.rotation;\n  }\n  set rotation(degrees: number) {\n    this.transform.rotation = degrees;\n  }\n\n  get localRotation(): number {\n    return this.transform.localRotation;\n  }\n  set localRotation(degrees: number) {\n    this.transform.localRotation = degrees;\n  }\n\n  get scale(): Vector {\n    return this.transform.scale;\n  }\n  set scale(scale: Vector) {\n    this.transform.scale = scale;\n  }\n\n  constructor(public id: string, position: Vector, controlPoints: Vector[]) {\n    this.transform = new Transform(\n      position,\n      0,\n      0,\n      Vector.Unit(),\n      controlPoints,\n      this\n    );\n    this.registeredEvents = {};\n    this.order = 0;\n  }\n\n  setHitColor() {\n    // Set unique color for hit detection in offscreen canvas\n    let color: string = Color.Random();\n    while (this.drawing.colorToNode[color]) {\n      color = Color.Random();\n    }\n\n    this.hitColor = color;\n    this.drawing.colorToNode[color] = this;\n\n    this.transform.childs.forEach((child) => {\n      child.node.setHitColor();\n    });\n  }\n\n  on(eventKey: string, callback: Function): void {\n    this.registeredEvents[eventKey] = callback;\n  }\n\n  render(): void {\n    this.context.save();\n    this._render();\n    this.context.restore();\n    this.offRender();\n\n    for (var child of this.transform.childs) {\n      child.node.render();\n    }\n  }\n\n  offRender(): void {\n    this.offContext.save();\n    this._offRender();\n    this.offContext.restore();\n  }\n\n  call(method: string, args?: any[]) {\n    if (this.registeredEvents[method]) {\n      if (args) {\n        this.registeredEvents[method](this, ...args);\n      } else {\n        this.registeredEvents[method](this);\n      }\n    }\n\n    for (var child of this.transform.childs) {\n      child.node.call(method, args);\n    }\n  }\n\n  setContext(\n    context: CanvasRenderingContext2D,\n    offContext: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D\n  ) {\n    this.context = context;\n    this.offContext = offContext;\n    this.transform.childs.forEach((child) => {\n      child.node.setContext(context, offContext);\n    });\n  }\n\n  setDrawing(drawing: Drawing) {\n    this.drawing = drawing;\n    this.transform.childs.forEach((child) => {\n      child.node.setDrawing(drawing);\n    });\n  }\n\n  dispose(): void {\n    this.drawing.remove(this.id);\n  }\n}\n","export class Dimension {\r\n  constructor(public width: number, public height: number) {}\r\n\r\n  max() {\r\n    return Math.max(this.width, this.height);\r\n  }\r\n}\r\n","export * from \"./dimension\";\r\nexport * from \"./matrix\";\r\nexport * from \"./transform\";\r\nexport * from \"./vector\";\r\n","/**\n * A 3x3 Matrix\n */\nexport class Matrix {\n  value: number[][];\n\n  constructor(value: number[][]) {\n    this.value = value;\n  }\n\n  /* istanbul ignore next */\n  private _multiply(another: Matrix | number[][]): number[][] {\n    let result;\n    if (another instanceof Matrix) {\n      result = [...Array(this.value.length)].map(() =>\n        Array(another.value[0].length)\n      );\n\n      for (let i = 0; i < this.value.length; i++) {\n        for (let j = 0; j < another.value[0].length; j++) {\n          let sum = 0;\n          for (let k = 0; k < this.value[0].length; k++) {\n            sum += this.value[i][k] * another.value[k][j];\n          }\n          result[i][j] = sum;\n        }\n      }\n    } else {\n      result = [...Array(this.value.length)].map(() =>\n        Array(another[0].length)\n      );\n\n      for (let i = 0; i < this.value.length; i++) {\n        for (let j = 0; j < another[0].length; j++) {\n          let sum = 0;\n          for (let k = 0; k < this.value[0].length; k++) {\n            sum += this.value[i][k] * another[k][j];\n          }\n          result[i][j] = sum;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  multiply(another: Matrix | number[][]): Matrix {\n    return new Matrix(this._multiply(another));\n  }\n\n  multiplyInPlace(another: Matrix | number[][]): Matrix {\n    this.value = this._multiply(another);\n    return this;\n  }\n\n  clone() {\n    return new Matrix([\n      [this.value[0][0], this.value[0][1], this.value[0][2]],\n      [this.value[1][0], this.value[1][1], this.value[1][2]],\n      [this.value[2][0], this.value[2][1], this.value[2][2]],\n    ]);\n  }\n\n  /**\n   * Decomposes the rotation component from matrix to get absolute rotation for a child transform\n   */\n  getRotation(): number {\n    return Math.atan2(this.value[0][1], this.value[0][0]) * (180 / Math.PI);\n  }\n\n  static Identity() {\n    return new Matrix([\n      [1, 0, 0],\n      [0, 1, 0],\n      [0, 0, 1],\n    ]);\n  }\n\n  static Zero() {\n    return new Matrix([\n      [0, 0, 0],\n      [0, 0, 0],\n      [0, 0, 0],\n    ]);\n  }\n\n  static Multiply(matrix1: number[][], matrix2: number[][]) {\n    let result = [...Array(matrix1.length)].map(() => Array(matrix2[0].length));\n\n    for (let i = 0; i < matrix1.length; i++) {\n      for (let j = 0; j < matrix2[0].length; j++) {\n        let sum = 0;\n        for (let k = 0; k < matrix1[0].length; k++) {\n          sum += matrix1[i][k] * matrix2[k][j];\n        }\n        result[i][j] = sum;\n      }\n    }\n\n    return result;\n  }\n}\n","import { Matrix, Vector } from \"./index\";\nimport { Constant } from \"../common/constants\";\nimport { Node } from \"../core/node\";\n\n// Stores a node's transform (position, rotation, scale)\nexport class Transform {\n  // reference control points to apply transform to\n  refControlPoints: Vector[];\n  // transformed control points\n  controlPoints: Vector[];\n  localTrasform: Matrix;\n  worldTransform: Matrix;\n  childs: Transform[];\n  private _parent: Transform;\n  private _position: Vector;\n  private _localRotation: number;\n  private _rotation: number;\n  private _scale: Vector;\n\n  get parent(): Transform {\n    return this._parent;\n  }\n  set parent(newParent: Transform) {\n    if (this._parent) {\n      const index = this._parent.childs.indexOf(this);\n      if (index > -1) {\n        this._parent.childs.splice(index, 1);\n      }\n    }\n    newParent && newParent.childs.push(this);\n    this._parent = newParent;\n\n    if (this._parent) {\n      this._parent.childs.sort((a, b) => {\n        return a.node.order - b.node.order;\n      });\n    }\n  }\n\n  get position(): Vector {\n    return this._position;\n  }\n  set position(newPosition: Vector) {\n    this._position = newPosition;\n  }\n\n  get absolutePosition(): Vector {\n    return Vector.Zero().transform(this.worldTransform);\n  }\n\n  get rotation(): number {\n    return this._rotation;\n  }\n  set rotation(degrees: number) {\n    this._rotation = degrees % 360;\n  }\n\n  get localRotation(): number {\n    return this._localRotation;\n  }\n  set localRotation(newRotation: number) {\n    this._localRotation = newRotation % 360;\n  }\n\n  get scale(): Vector {\n    return this._scale;\n  }\n  set scale(newScale: Vector) {\n    this._scale = newScale;\n  }\n\n  constructor(\n    position: Vector,\n    localRotation: number,\n    rotation: number,\n    scale: Vector,\n    controlPoints: Vector[],\n    public node: Node\n  ) {\n    this._position = position;\n    this._localRotation = localRotation;\n    this._rotation = rotation;\n    this._scale = scale;\n    this._parent = null;\n    this.childs = [];\n    this.localTrasform = Matrix.Identity();\n    this.worldTransform = Matrix.Identity();\n    this.refControlPoints = this.relativeControlPoints(controlPoints);\n    this.controlPoints = [...controlPoints];\n  }\n\n  /* istanbul ignore next */\n  private relativeControlPoints(controlPoints: Vector[]): Vector[] {\n    let result: Vector[] = [];\n    controlPoints.forEach((controlPoint) => {\n      result.push(controlPoint.subtract(this.position));\n    });\n    return result;\n  }\n\n  // Transforms each control point using this node's worldTransform\n  /* istanbul ignore next */\n  private applyTransform() {\n    this.refControlPoints.forEach((controlPoint, index) => {\n      this.controlPoints[index] = controlPoint.transform(this.worldTransform);\n    });\n  }\n\n  /* istanbul ignore next */\n  private _updateWorldTransform(parentWorldTransform?: Matrix) {\n    // Set translation\n    this.localTrasform.value = [\n      [1, 0, 0],\n      [0, 1, 0],\n      [this.position.x, this.position.y, 1],\n    ];\n\n    let cos;\n    let sin;\n    // Transform rotation\n    if (this.parent.node.id != \"#Root\") {\n      cos = Math.cos(this.rotation * Constant.TAU);\n      sin = Math.sin(this.rotation * Constant.TAU);\n\n      this.localTrasform = new Matrix([\n        [1, 0, 0],\n        [0, 1, 0],\n        [this.position.x, this.position.y, 1],\n      ])\n        .multiply([\n          [cos, sin, 0],\n          [-sin, cos, 0],\n          [0, 0, 1],\n        ])\n        .multiply([\n          [1, 0, 0],\n          [0, 1, 0],\n          [-this.position.x, -this.position.y, 1],\n        ])\n        .multiply(this.localTrasform);\n    }\n\n    // Transform localRotation\n    cos = Math.cos(this.localRotation * Constant.TAU);\n    sin = Math.sin(this.localRotation * Constant.TAU);\n    this.localTrasform = new Matrix([\n      [cos, sin, 0],\n      [-sin, cos, 0],\n      [0, 0, 1],\n    ]).multiply(this.localTrasform);\n\n    // Transform scale\n    this.localTrasform = new Matrix([\n      [this.scale.x, 0, 0],\n      [0, this.scale.y, 0],\n      [0, 0, 1],\n    ]).multiply(this.localTrasform);\n\n    if (parentWorldTransform) {\n      this.worldTransform = this.localTrasform.multiply(parentWorldTransform);\n    } else {\n      this.worldTransform = this.localTrasform.clone();\n    }\n\n    this.childs.forEach((child) => {\n      child.updateWorldTransform(this.worldTransform);\n    });\n\n    this.applyTransform();\n  }\n\n  // Updates this node's worldTransform using parent's worldTransform if any\n  updateWorldTransform(parentWorldTransform?: Matrix) {\n    this._updateWorldTransform(parentWorldTransform);\n  }\n}\n","import { Canvas } from \"../core/canvas\";\nimport { Constant } from \"../common/constants\";\nimport { Matrix } from \"../math/matrix\";\n\n/**\n * Stores 2D Vector\n */\nexport class Vector {\n  tmpX: number;\n  tmpY: number;\n\n  constructor(public x: number, public y: number) {}\n\n  toString() {\n    return \"[\" + this.x.toFixed(3) + \", \" + this.y.toFixed(3) + \"]\";\n  }\n\n  add(x: number, y: number): Vector;\n  add(value: number): Vector;\n  add(vector: Vector): Vector;\n  add(arg1: number | Vector, arg2?: number): Vector {\n    // Params : (vector) or (x, y)\n    if (arg1 instanceof Vector) {\n      return new Vector(this.x + arg1.x, this.y + arg1.y);\n    } else if (typeof arg2 === \"undefined\") {\n      return new Vector(this.x + arg1, this.y + arg1);\n    } else {\n      return new Vector(this.x + arg1, this.y + arg2);\n    }\n  }\n\n  addInPlace(x: number, y: number): Vector;\n  addInPlace(value: number): Vector;\n  addInPlace(vector: Vector): Vector;\n  addInPlace(arg1: number | Vector, arg2?: number): Vector {\n    // Params : (vector) or (x, y)\n    if (arg1 instanceof Vector) {\n      this.x += arg1.x;\n      this.y += arg1.y;\n    } else if (typeof arg2 === \"undefined\") {\n      this.x += arg1;\n      this.y += arg1;\n    } else {\n      this.x += arg1;\n      this.y += arg2;\n    }\n    return this;\n  }\n\n  multiply(x: number, y: number): Vector;\n  multiply(value: number): Vector;\n  multiply(vector: Vector): Vector;\n  multiply(arg1: number | Vector, arg2?: number): Vector {\n    // Params : (vector) or (x, y)\n    if (arg1 instanceof Vector) {\n      return new Vector(this.x * arg1.x, this.y * arg1.y);\n    } else if (typeof arg2 === \"undefined\") {\n      return new Vector(this.x * arg1, this.y * arg1);\n    } else {\n      return new Vector(this.x * arg1, this.y * arg2);\n    }\n  }\n\n  multiplyInPlace(x: number, y: number): Vector;\n  multiplyInPlace(value: number): Vector;\n  multiplyInPlace(vector: Vector): Vector;\n  multiplyInPlace(arg1: number | Vector, arg2?: number): Vector {\n    // Params : (vector) or (x, y)\n    if (arg1 instanceof Vector) {\n      this.x *= arg1.x;\n      this.y *= arg1.y;\n    } else if (typeof arg2 === \"undefined\") {\n      this.x *= arg1;\n      this.y *= arg1;\n    } else {\n      this.x *= arg1;\n      this.y *= arg2;\n    }\n    return this;\n  }\n\n  subtract(x: number, y: number): Vector;\n  subtract(value: number): Vector;\n  subtract(vector: Vector): Vector;\n  subtract(arg1: number | Vector, arg2?: number): Vector {\n    // Params : (vector) or (x, y)\n    if (arg1 instanceof Vector) {\n      return new Vector(this.x - arg1.x, this.y - arg1.y);\n    } else if (typeof arg2 === \"undefined\") {\n      return new Vector(this.x - arg1, this.y - arg1);\n    } else {\n      return new Vector(this.x - arg1, this.y - arg2);\n    }\n  }\n\n  subtractInPlace(x: number, y: number): Vector;\n  subtractInPlace(value: number): Vector;\n  subtractInPlace(vector: Vector): Vector;\n  subtractInPlace(arg1: number | Vector, arg2?: number): Vector {\n    // Params : (vector) or (x, y)\n    if (arg1 instanceof Vector) {\n      this.x -= arg1.x;\n      this.y -= arg1.y;\n    } else if (typeof arg2 === \"undefined\") {\n      this.x -= arg1;\n      this.y -= arg1;\n    } else {\n      this.x -= arg1;\n      this.y -= arg2;\n    }\n\n    return this;\n  }\n\n  rotate(pivot: Vector, degrees: number): Vector {\n    degrees = degrees * Constant.TAU;\n    let cosT = Math.cos(degrees);\n    let sinT = Math.sin(degrees);\n    return new Vector(\n      cosT * (this.x - pivot.x) - sinT * (this.y - pivot.y) + pivot.x,\n      sinT * (this.x - pivot.x) + cosT * (this.y - pivot.y) + pivot.y\n    );\n  }\n\n  rotateInPlace(pivot: Vector, degrees: number): Vector {\n    degrees = degrees * Constant.TAU;\n    let cosT = Math.cos(degrees);\n    let sinT = Math.sin(degrees);\n    this.tmpX = cosT * (this.x - pivot.x) - sinT * (this.y - pivot.y) + pivot.x;\n    this.tmpY = sinT * (this.x - pivot.x) + cosT * (this.y - pivot.y) + pivot.y;\n    this.x = this.tmpX;\n    this.y = this.tmpY;\n    return this;\n  }\n\n  transform(matrix: Matrix) {\n    let result = Matrix.Multiply([[this.x, this.y, 1]], matrix.value);\n    return new Vector(result[0][0], result[0][1]);\n  }\n\n  transformInPlace(matrix: Matrix): Vector {\n    let result = Matrix.Multiply([[this.x, this.y, 1]], matrix.value);\n    this.x = result[0][0];\n    this.y = result[0][1];\n    return this;\n  }\n\n  max() {\n    return Math.max(this.x, this.y);\n  }\n\n  static Midpoint(vector1: Vector, vector2: Vector): Vector {\n    return new Vector((vector1.x + vector2.x) / 2, (vector1.y + vector2.y) / 2);\n  }\n\n  static Distance(vector1: Vector, vector2: Vector): number {\n    return Math.sqrt(\n      Math.pow(vector2.x - vector1.x, 2) + Math.pow(vector2.y - vector1.y, 2)\n    );\n  }\n\n  static Zero(): Vector {\n    return new Vector(0, 0);\n  }\n\n  static Unit(): Vector {\n    return new Vector(1, 1);\n  }\n\n  static Bounds(vectors: Vector[]): Vector[] {\n    let minVec = new Vector(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\n    let maxVec = new Vector(Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);\n\n    vectors.forEach((vector) => {\n      if (vector.x < minVec.x) minVec.x = vector.x;\n      if (vector.y < minVec.y) minVec.y = vector.y;\n      if (vector.x > maxVec.x) maxVec.x = vector.x;\n      if (vector.y > maxVec.y) maxVec.y = vector.y;\n    });\n    return [minVec, maxVec];\n  }\n\n  static Average(vectors: Vector[]): Vector {\n    let sumX = 0;\n    let sumY = 0;\n    vectors.forEach((vector) => {\n      sumX += vector.x;\n      sumY += vector.y;\n    });\n    return new Vector(sumX / vectors.length, sumY / vectors.length);\n  }\n\n  static Random(canvas: Canvas): Vector;\n  static Random(minX: number, maxX: number, minY: number, maxY: number): Vector;\n  static Random(\n    minXOrCanvas: number | Canvas,\n    maxX?: number,\n    minY?: number,\n    maxY?: number\n  ): Vector {\n    if (minXOrCanvas instanceof Canvas) {\n      return new Vector(\n        Math.random() * minXOrCanvas.width,\n        Math.random() * minXOrCanvas.height\n      );\n    } else {\n      return new Vector(\n        Math.random() * (maxX - minXOrCanvas) + minXOrCanvas,\n        Math.random() * (maxY - minY) + minY\n      );\n    }\n  }\n\n  static Lerp(start: Vector, end: Vector, amount: number): Vector {\n    return new Vector(\n      start.x + (end.x - start.x) * amount,\n      start.y + (end.y - start.y) * amount\n    );\n  }\n\n  clone(): Vector {\n    return new Vector(this.x, this.y);\n  }\n}\n","export * from \"./common\";\r\nexport * as View from \"./view\";\r\nexport * from \"./core\";\r\nexport * from \"./math\";\r\n","import { Vector } from \"../math/vector\";\nimport { LinearGradient, RadialGradient } from \"./index\";\nimport { Node } from \"../core/node\";\n\nexport interface EllipseOptions {\n  outline?: boolean;\n  fill?: boolean;\n  outlineColor?: string | LinearGradient | RadialGradient;\n  fillColor?: string | LinearGradient | RadialGradient;\n  outlineWidth?: number;\n  outlineDashSegments?: number[];\n  shadowColor?: string;\n  shadowOffset?: Vector;\n  staticShadow?: boolean;\n  shadowBlur?: number;\n}\n\nexport class Ellipse extends Node {\n  constructor(\n    id: string,\n    position: Vector,\n    public minor: number,\n    public major: number,\n    public props: EllipseOptions = {}\n  ) {\n    super(id, position, [\n      position.subtract(0, minor),\n      position.add(major, 0),\n      position.add(0, minor),\n      position.subtract(major, 0),\n    ]);\n\n    if (\n      this.props.outlineColor &&\n      typeof this.props.outlineColor !== \"string\"\n    ) {\n      this.props.outlineColor.node = this;\n    }\n    if (this.props.fillColor && typeof this.props.fillColor !== \"string\") {\n      this.props.fillColor.node = this;\n    }\n  }\n\n  /* istanbul ignore next */\n  _render(): void {\n    if (this.props) {\n      this.props.outlineColor &&\n        (this.context.strokeStyle =\n          typeof this.props.outlineColor == \"string\"\n            ? this.props.outlineColor\n            : this.props.outlineColor.create(this.context));\n      this.props.fillColor &&\n        (this.context.fillStyle =\n          typeof this.props.fillColor == \"string\"\n            ? this.props.fillColor\n            : this.props.fillColor.create(this.context));\n      this.props.outlineWidth &&\n        (this.context.lineWidth = this.props.outlineWidth);\n      this.props.outlineDashSegments &&\n        this.context.setLineDash(this.props.outlineDashSegments);\n      this.props.shadowColor &&\n        (this.context.shadowColor = this.props.shadowColor);\n      this.props.shadowBlur &&\n        (this.context.shadowBlur = this.props.shadowBlur);\n      if (this.props.shadowOffset) {\n        if (!this.props.staticShadow) {\n          let shadowOffset = this.props.shadowOffset\n            .transform(this.transform.worldTransform)\n            .subtract(this.absolutePosition);\n          this.context.shadowOffsetX = shadowOffset.x;\n          this.context.shadowOffsetY = shadowOffset.y;\n        } else {\n          this.context.shadowOffsetX = this.props.shadowOffset.x;\n          this.context.shadowOffsetY = this.props.shadowOffset.y;\n        }\n      }\n    }\n\n    let position = this.absolutePosition;\n    this.context.beginPath();\n    if (this.minor == this.major) {\n      this.context.arc(position.x, position.y, this.minor, 0, 2 * Math.PI);\n    } else {\n      this.context.ellipse(\n        position.x,\n        position.y,\n        this.major,\n        this.minor,\n        Math.atan2(\n          this.transform.controlPoints[1].y - position.y,\n          this.transform.controlPoints[1].x - position.x\n        ),\n        0,\n        2 * Math.PI\n      );\n    }\n    if (this.props.fill) {\n      this.context.fill();\n    }\n    if (this.props.outline || !this.props.fill) {\n      this.context.stroke();\n    }\n  }\n\n  /* istanbul ignore next */\n  _offRender(): void {\n    this.props.outlineWidth &&\n      (this.offContext.lineWidth = this.props.outlineWidth);\n    this.offContext.strokeStyle = this.hitColor;\n    this.offContext.fillStyle = this.hitColor;\n\n    let position = this.absolutePosition;\n    this.offContext.beginPath();\n    if (this.minor == this.major) {\n      this.offContext.arc(position.x, position.y, this.minor, 0, 2 * Math.PI);\n    } else {\n      this.offContext.ellipse(\n        position.x,\n        position.y,\n        this.major,\n        this.minor,\n        Math.atan2(\n          this.transform.controlPoints[1].y - position.y,\n          this.transform.controlPoints[1].x - position.x\n        ),\n        0,\n        2 * Math.PI\n      );\n    }\n    if (this.props.fill) {\n      this.offContext.fill();\n    }\n    if (this.props.outline || !this.props.fill) {\n      this.offContext.stroke();\n    }\n  }\n\n  getDimension(): Vector {\n    return new Vector(\n      Vector.Distance(\n        this.transform.controlPoints[1],\n        this.transform.controlPoints[3]\n      ),\n      Vector.Distance(\n        this.transform.controlPoints[0],\n        this.transform.controlPoints[2]\n      )\n    );\n  }\n}\n","import { Vector } from \"../math/vector\";\nimport { Node } from \"../core/node\";\n\nexport class Empty extends Node {\n  constructor(id: string, position: Vector) {\n    super(id, position, []);\n  }\n\n  _render(): void {\n    /**/\n  }\n  _offRender(): void {\n    /**/\n  }\n\n  getDimension(): Vector {\n    return Vector.Zero();\n  }\n}\n","import { Vector } from \"../math/vector\";\nimport { Node } from \"../core/node\";\n\nexport interface ImageOptions {\n  shadowColor?: string;\n  shadowOffset?: Vector;\n  staticShadow?: boolean;\n  shadowBlur?: number;\n}\n\nexport class Image extends Node {\n  _source: HTMLImageElement;\n\n  constructor(\n    id: string,\n    position: Vector,\n    source: string | HTMLImageElement,\n    public width: number,\n    public height: number,\n    public props: ImageOptions = {}\n  ) {\n    super(id, position, []);\n\n    if (typeof source == \"string\") {\n      this._source = new window.Image();\n      this._source.src = source;\n    } else {\n      this._source = source;\n    }\n    this._source.crossOrigin = \"Anonymous\";\n  }\n\n  /* istanbul ignore next */\n  _render(): void {\n    if (this.props) {\n      this.props.shadowColor &&\n        (this.context.shadowColor = this.props.shadowColor);\n      this.props.shadowBlur &&\n        (this.context.shadowBlur = this.props.shadowBlur);\n      if (this.props.shadowOffset) {\n        if (!this.props.staticShadow) {\n          let shadowOffset = this.props.shadowOffset\n            .transform(this.transform.worldTransform)\n            .subtract(this.absolutePosition);\n          this.context.shadowOffsetX = shadowOffset.x;\n          this.context.shadowOffsetY = shadowOffset.y;\n        } else {\n          this.context.shadowOffsetX = this.props.shadowOffset.x;\n          this.context.shadowOffsetY = this.props.shadowOffset.y;\n        }\n      }\n    }\n\n    // Rotate image using worldTransform's rotation component\n    this.context.translate(this.absolutePosition.x, this.absolutePosition.y);\n    this.context.rotate(\n      this.transform.worldTransform.getRotation() * (Math.PI / 180)\n    );\n    this.context.translate(-this.absolutePosition.x, -this.absolutePosition.y);\n\n    let topLeft = this.absolutePosition.subtract(\n      (this.width * this.transform.scale.x) / 2,\n      (this.height * this.transform.scale.y) / 2\n    );\n    this.context.drawImage(\n      this._source,\n      topLeft.x,\n      topLeft.y,\n      this.width * this.transform.scale.x,\n      this.height * this.transform.scale.y\n    );\n  }\n\n  /* istanbul ignore next */\n  _offRender(): void {\n    this.offContext.fillStyle = this.hitColor;\n\n    // Rotate bounding-rectangle using worldTransform's rotation component\n    this.offContext.translate(this.absolutePosition.x, this.absolutePosition.y);\n    this.offContext.rotate(\n      this.transform.worldTransform.getRotation() * (Math.PI / 180)\n    );\n    this.offContext.translate(\n      -this.absolutePosition.x,\n      -this.absolutePosition.y\n    );\n\n    let topLeft = this.absolutePosition.subtract(\n      (this.width * this.transform.scale.x) / 2,\n      (this.height * this.transform.scale.y) / 2\n    );\n    this.offContext.fillRect(\n      topLeft.x,\n      topLeft.y,\n      this.width * this.transform.scale.x,\n      this.height * this.transform.scale.y\n    );\n  }\n\n  getDimension(): Vector {\n    return new Vector(this.width, this.height);\n  }\n}\n","export * from \"./ellipse\";\r\nexport * from \"./empty\";\r\nexport * from \"./image\";\r\nexport * from \"./line\";\r\nexport * from \"./polygon\";\r\nexport * from \"./rectangle\";\r\nexport * from \"./text\";\r\nexport * from \"./linear-gradient\";\r\nexport * from \"./radial-gradient\";\r\n","import { Vector } from \"../math/vector\";\nimport { LinearGradient, RadialGradient } from \".\";\nimport { Node } from \"../core/node\";\n\nexport interface LineOptions {\n  color?: string | LinearGradient | RadialGradient;\n  lineWidth?: number;\n  lineCap?: CanvasLineCap;\n  lineDashSegments?: number[];\n  shadowColor?: string;\n  shadowOffset?: Vector;\n  staticShadow?: boolean;\n  shadowBlur?: number;\n}\n\nexport class Line extends Node {\n  get from(): Vector {\n    if (this._from instanceof Node) return this._from.absolutePosition;\n    else return this.transform.controlPoints[0];\n  }\n  get to(): Vector {\n    if (this._to instanceof Node) return this._to.absolutePosition;\n    else return this.transform.controlPoints[1];\n  }\n\n  constructor(\n    id: string,\n    public _from: Vector | Node,\n    public _to: Vector | Node,\n    pivot?: number,\n    public props: LineOptions = {}\n  ) {\n    super(\n      id,\n      _from instanceof Vector && _to instanceof Vector\n        ? pivot\n          ? _from.add((_to.x - _from.x) * pivot, (_to.y - _from.y) * pivot)\n          : _from.clone()\n        : Vector.Zero(),\n      _from instanceof Vector && _to instanceof Vector ? [_from, _to] : []\n    );\n\n    if (this.props.color && typeof this.props.color !== \"string\") {\n      this.props.color.node = this;\n    }\n  }\n\n  /* istanbul ignore next */\n  _render(): void {\n    if (this.props) {\n      this.props.color &&\n        (this.context.strokeStyle =\n          typeof this.props.color == \"string\"\n            ? this.props.color\n            : this.props.color.create(this.context));\n      this.props.lineWidth && (this.context.lineWidth = this.props.lineWidth);\n      this.props.lineCap && (this.context.lineCap = this.props.lineCap);\n      this.props.lineDashSegments &&\n        this.context.setLineDash(this.props.lineDashSegments);\n      this.props.shadowColor &&\n        (this.context.shadowColor = this.props.shadowColor);\n      this.props.shadowBlur &&\n        (this.context.shadowBlur = this.props.shadowBlur);\n      if (this.props.shadowOffset) {\n        if (!this.props.staticShadow) {\n          let shadowOffset = this.props.shadowOffset\n            .transform(this.transform.worldTransform)\n            .subtract(this.absolutePosition);\n          this.context.shadowOffsetX = shadowOffset.x;\n          this.context.shadowOffsetY = shadowOffset.y;\n        } else {\n          this.context.shadowOffsetX = this.props.shadowOffset.x;\n          this.context.shadowOffsetY = this.props.shadowOffset.y;\n        }\n      }\n    }\n\n    this.context.beginPath();\n    this.context.moveTo(this.from.x, this.from.y);\n    this.context.lineTo(this.to.x, this.to.y);\n    this.context.stroke();\n  }\n\n  /* istanbul ignore next */\n  _offRender(): void {\n    this.props.lineWidth && (this.offContext.lineWidth = this.props.lineWidth);\n    this.offContext.strokeStyle = this.hitColor;\n\n    this.offContext.beginPath();\n    this.offContext.moveTo(this.from.x, this.from.y);\n    this.offContext.lineTo(this.to.x, this.to.y);\n    this.offContext.stroke();\n  }\n\n  getDimension(): Vector {\n    return new Vector(\n      Vector.Distance(\n        this.transform.controlPoints[0],\n        this.transform.controlPoints[1]\n      ),\n      0\n    );\n  }\n}\n","import { Constant, Handle } from \"../common\";\nimport { Node } from \"../core/node\";\nimport { Vector } from \"../math/vector\";\n\nexport class LinearGradient {\n  node: Node;\n\n  constructor(\n    public offset: Vector,\n    public degrees: number,\n    public length: number | Handle,\n    public colors: string[],\n    public weights: number[]\n  ) {}\n\n  create(context: CanvasRenderingContext2D): CanvasGradient {\n    let gradient: CanvasGradient,\n      from,\n      to,\n      length,\n      delta = new Vector(0, 0);\n\n    length =\n      this.length == Handle.AUTO ? this.node.getDimension().max() : this.length;\n    delta.x = (length / 2) * Math.cos(this.degrees * Constant.TAU);\n    delta.y = (length / 2) * Math.sin(this.degrees * Constant.TAU);\n\n    from = this.offset\n      .subtract(delta)\n      .transform(this.node.transform.worldTransform);\n    to = this.offset.add(delta).transform(this.node.transform.worldTransform);\n\n    gradient = context.createLinearGradient(from.x, from.y, to.x, to.y);\n    this.colors.forEach((color, index) => {\n      gradient.addColorStop(this.weights[index], color);\n    });\n    return gradient;\n  }\n}\n","import { Vector } from \"../math/vector\";\nimport { LinearGradient, RadialGradient } from \"./index\";\nimport { Node } from \"../core/node\";\nimport { Handle } from \"../common/enums\";\n\nexport interface PolygonOptions {\n  outline?: boolean;\n  fill?: boolean;\n  outlineColor?: string | LinearGradient | RadialGradient;\n  fillColor?: string | LinearGradient | RadialGradient;\n  outlineWidth?: number;\n  outlineDashSegments?: number[];\n  shadowColor?: string;\n  shadowOffset?: Vector;\n  staticShadow?: boolean;\n  shadowBlur?: number;\n}\n\nexport class Polygon extends Node {\n  constructor(\n    id: string,\n    vertices: Vector[],\n    center: Vector | Handle,\n    public props: PolygonOptions = {}\n  ) {\n    super(\n      id,\n      center instanceof Vector ? center : Vector.Average(vertices),\n      vertices\n    );\n\n    if (\n      this.props.outlineColor &&\n      typeof this.props.outlineColor !== \"string\"\n    ) {\n      this.props.outlineColor.node = this;\n    }\n    if (this.props.fillColor && typeof this.props.fillColor !== \"string\") {\n      this.props.fillColor.node = this;\n    }\n  }\n\n  /* istanbul ignore next */\n  _render(): void {\n    if (this.props) {\n      this.props.outlineColor &&\n        (this.context.strokeStyle =\n          typeof this.props.outlineColor == \"string\"\n            ? this.props.outlineColor\n            : this.props.outlineColor.create(this.context));\n      this.props.fillColor &&\n        (this.context.fillStyle =\n          typeof this.props.fillColor == \"string\"\n            ? this.props.fillColor\n            : this.props.fillColor.create(this.context));\n      this.props.outlineWidth &&\n        (this.context.lineWidth = this.props.outlineWidth);\n      this.props.outlineDashSegments &&\n        this.context.setLineDash(this.props.outlineDashSegments);\n      this.props.shadowColor &&\n        (this.context.shadowColor = this.props.shadowColor);\n      this.props.shadowBlur &&\n        (this.context.shadowBlur = this.props.shadowBlur);\n      if (this.props.shadowOffset) {\n        if (!this.props.staticShadow) {\n          let shadowOffset = this.props.shadowOffset\n            .transform(this.transform.worldTransform)\n            .subtract(this.absolutePosition);\n          this.context.shadowOffsetX = shadowOffset.x;\n          this.context.shadowOffsetY = shadowOffset.y;\n        } else {\n          this.context.shadowOffsetX = this.props.shadowOffset.x;\n          this.context.shadowOffsetY = this.props.shadowOffset.y;\n        }\n      }\n    }\n\n    this.context.beginPath();\n    this.context.moveTo(\n      this.transform.controlPoints[0].x,\n      this.transform.controlPoints[0].y\n    );\n    for (let index = 1; index < this.transform.controlPoints.length; index++) {\n      this.context.lineTo(\n        this.transform.controlPoints[index].x,\n        this.transform.controlPoints[index].y\n      );\n    }\n    this.context.closePath();\n\n    if (this.props.fill) {\n      this.context.fill();\n    }\n    if (this.props.outline || !this.props.fill) {\n      this.context.stroke();\n    }\n  }\n\n  /* istanbul ignore next */\n  _offRender(): void {\n    this.props.outlineWidth &&\n      (this.offContext.lineWidth = this.props.outlineWidth);\n    this.offContext.strokeStyle = this.hitColor;\n    this.offContext.fillStyle = this.hitColor;\n\n    this.offContext.beginPath();\n    this.offContext.moveTo(\n      this.transform.controlPoints[0].x,\n      this.transform.controlPoints[0].y\n    );\n    for (let index = 1; index < this.transform.controlPoints.length; index++) {\n      this.offContext.lineTo(\n        this.transform.controlPoints[index].x,\n        this.transform.controlPoints[index].y\n      );\n    }\n    this.offContext.closePath();\n\n    if (this.props.fill) {\n      this.offContext.fill();\n    }\n    if (this.props.outline || !this.props.fill) {\n      this.offContext.stroke();\n    }\n  }\n\n  getDimension(): Vector {\n    let bounds = Vector.Bounds(this.transform.controlPoints);\n\n    return new Vector(\n      Math.abs(bounds[0].x - bounds[1].x),\n      Math.abs(bounds[0].y - bounds[1].y)\n    );\n  }\n}\n","import { Vector } from \"../math/vector\";\nimport { Handle } from \"../common/enums\";\nimport { Node } from \"../core/node\";\n\nexport class RadialGradient {\n  node: Node;\n\n  constructor(\n    public fromOffset: Vector,\n    public fromRadius: number | Handle,\n    public toOffset: Vector,\n    public toRadius: number | Handle,\n    public colors: string[],\n    public weights: number[]\n  ) {}\n\n  create(context: CanvasRenderingContext2D): CanvasGradient {\n    let gradient: CanvasGradient;\n    let fromCenter = this.fromOffset.transform(\n      this.node.transform.worldTransform\n    );\n    let toCenter = this.toOffset.transform(this.node.transform.worldTransform);\n    let fromRadius, toRadius;\n    if (this.fromRadius == Handle.AUTO || this.toRadius == Handle.AUTO) {\n      fromRadius = 1;\n      toRadius = this.node.getDimension().max() / 2;\n    } else {\n      fromRadius = this.fromRadius;\n      toRadius = this.toRadius;\n    }\n\n    gradient = context.createRadialGradient(\n      fromCenter.x,\n      fromCenter.y,\n      fromRadius,\n      toCenter.x,\n      toCenter.y,\n      toRadius\n    );\n    this.colors.forEach((color, index) => {\n      gradient.addColorStop(this.weights[index], color);\n    });\n    return gradient;\n  }\n}\n","import { Vector } from \"../math/vector\";\nimport { LinearGradient, RadialGradient } from \"./index\";\nimport { Node } from \"../core/node\";\n\nexport interface RectangleOptions {\n  outline?: boolean;\n  fill?: boolean;\n  outlineColor?: string | LinearGradient | RadialGradient;\n  fillColor?: string | LinearGradient | RadialGradient;\n  outlineWidth?: number;\n  outlineDashSegments?: number[];\n  shadowColor?: string;\n  shadowOffset?: Vector;\n  staticShadow?: boolean;\n  shadowBlur?: number;\n}\n\nexport class Rectangle extends Node {\n  constructor(\n    id: string,\n    position: Vector,\n    width: number,\n    height: number,\n    public props: RectangleOptions = {}\n  ) {\n    super(id, position, [\n      position.add(-width / 2, -height / 2),\n      position.add(width / 2, -height / 2),\n      position.add(width / 2, height / 2),\n      position.add(-width / 2, height / 2),\n    ]);\n\n    if (\n      this.props.outlineColor &&\n      typeof this.props.outlineColor !== \"string\"\n    ) {\n      this.props.outlineColor.node = this;\n    }\n    if (this.props.fillColor && typeof this.props.fillColor !== \"string\") {\n      this.props.fillColor.node = this;\n    }\n  }\n\n  /* istanbul ignore next */\n  _render(): void {\n    if (this.props) {\n      this.props.outlineColor &&\n        (this.context.strokeStyle =\n          typeof this.props.outlineColor == \"string\"\n            ? this.props.outlineColor\n            : this.props.outlineColor.create(this.context));\n      this.props.fillColor &&\n        (this.context.fillStyle =\n          typeof this.props.fillColor == \"string\"\n            ? this.props.fillColor\n            : this.props.fillColor.create(this.context));\n      this.props.outlineWidth &&\n        (this.context.lineWidth = this.props.outlineWidth);\n      this.props.outlineDashSegments &&\n        this.context.setLineDash(this.props.outlineDashSegments);\n      this.props.shadowColor &&\n        (this.context.shadowColor = this.props.shadowColor);\n      this.props.shadowBlur &&\n        (this.context.shadowBlur = this.props.shadowBlur);\n      if (this.props.shadowOffset) {\n        if (!this.props.staticShadow) {\n          let shadowOffset = this.props.shadowOffset\n            .transform(this.transform.worldTransform)\n            .subtract(this.absolutePosition);\n          this.context.shadowOffsetX = shadowOffset.x;\n          this.context.shadowOffsetY = shadowOffset.y;\n        } else {\n          this.context.shadowOffsetX = this.props.shadowOffset.x;\n          this.context.shadowOffsetY = this.props.shadowOffset.y;\n        }\n      }\n    }\n\n    this.context.beginPath();\n    this.context.moveTo(\n      this.transform.controlPoints[0].x,\n      this.transform.controlPoints[0].y\n    );\n    this.context.lineTo(\n      this.transform.controlPoints[1].x,\n      this.transform.controlPoints[1].y\n    );\n    this.context.lineTo(\n      this.transform.controlPoints[2].x,\n      this.transform.controlPoints[2].y\n    );\n    this.context.lineTo(\n      this.transform.controlPoints[3].x,\n      this.transform.controlPoints[3].y\n    );\n    this.context.lineTo(\n      this.transform.controlPoints[0].x,\n      this.transform.controlPoints[0].y\n    );\n    if (this.props.fill) {\n      this.context.fill();\n    }\n    if (this.props.outline || !this.props.fill) {\n      this.context.stroke();\n    }\n  }\n\n  /* istanbul ignore next */\n  _offRender(): void {\n    this.props.outlineWidth &&\n      (this.offContext.lineWidth = this.props.outlineWidth);\n    this.offContext.strokeStyle = this.hitColor;\n    this.offContext.fillStyle = this.hitColor;\n\n    this.offContext.beginPath();\n    this.offContext.moveTo(\n      this.transform.controlPoints[0].x,\n      this.transform.controlPoints[0].y\n    );\n    this.offContext.lineTo(\n      this.transform.controlPoints[1].x,\n      this.transform.controlPoints[1].y\n    );\n    this.offContext.lineTo(\n      this.transform.controlPoints[2].x,\n      this.transform.controlPoints[2].y\n    );\n    this.offContext.lineTo(\n      this.transform.controlPoints[3].x,\n      this.transform.controlPoints[3].y\n    );\n    this.offContext.lineTo(\n      this.transform.controlPoints[0].x,\n      this.transform.controlPoints[0].y\n    );\n    if (this.props.fill) {\n      this.offContext.fill();\n    }\n    if (this.props.outline || !this.props.fill) {\n      this.offContext.stroke();\n    }\n  }\n\n  getDimension(): Vector {\n    return new Vector(\n      Vector.Distance(\n        this.transform.controlPoints[0],\n        this.transform.controlPoints[1]\n      ),\n      Vector.Distance(\n        this.transform.controlPoints[1],\n        this.transform.controlPoints[2]\n      )\n    );\n  }\n}\n","import { Vector } from \"../math/vector\";\nimport { LinearGradient, RadialGradient } from \"./index\";\nimport { Node } from \"../core/node\";\n\nexport interface TextOptions {\n  font?: string;\n  outline?: boolean;\n  fill?: boolean;\n  outlineColor?: string | LinearGradient | RadialGradient;\n  fillColor?: string | LinearGradient | RadialGradient;\n  outlineWidth?: number;\n  shadowColor?: string;\n  shadowOffset?: Vector;\n  staticShadow?: boolean;\n  shadowBlur?: number;\n}\n\nexport class Text extends Node {\n  _text: string;\n  _originalWidth: number;\n  _originalHeight: number;\n\n  get text(): string {\n    return this._text;\n  }\n  set text(text: string) {\n    this._text = text;\n  }\n\n  constructor(\n    id: string,\n    position: Vector,\n    text: string,\n    public props: TextOptions = {}\n  ) {\n    super(id, position, []);\n\n    this.text = text;\n    if (\n      this.props.outlineColor &&\n      typeof this.props.outlineColor !== \"string\"\n    ) {\n      this.props.outlineColor.node = this;\n    }\n    if (this.props.fillColor && typeof this.props.fillColor !== \"string\") {\n      this.props.fillColor.node = this;\n    }\n\n    let textMetricContext = document.createElement(\"canvas\").getContext(\"2d\");\n    this.props.font && (textMetricContext.font = this.props.font);\n    this._originalWidth = textMetricContext.measureText(text).width;\n    this._originalHeight = textMetricContext.measureText(\"M\").width;\n  }\n\n  /* istanbul ignore next */\n  _render(): void {\n    if (this.props) {\n      this.props.outlineColor &&\n        (this.context.strokeStyle =\n          typeof this.props.outlineColor == \"string\"\n            ? this.props.outlineColor\n            : this.props.outlineColor.create(this.context));\n      this.props.fillColor &&\n        (this.context.fillStyle =\n          typeof this.props.fillColor == \"string\"\n            ? this.props.fillColor\n            : this.props.fillColor.create(this.context));\n      this.props.outlineWidth &&\n        (this.context.lineWidth = this.props.outlineWidth);\n      this.props.shadowColor &&\n        (this.context.shadowColor = this.props.shadowColor);\n      this.props.shadowBlur &&\n        (this.context.shadowBlur = this.props.shadowBlur);\n      if (this.props.shadowOffset) {\n        if (!this.props.staticShadow) {\n          let shadowOffset = this.props.shadowOffset\n            .transform(this.transform.worldTransform)\n            .subtract(this.absolutePosition);\n          this.context.shadowOffsetX = shadowOffset.x;\n          this.context.shadowOffsetY = shadowOffset.y;\n        } else {\n          this.context.shadowOffsetX = this.props.shadowOffset.x;\n          this.context.shadowOffsetY = this.props.shadowOffset.y;\n        }\n      }\n      this.props.font && (this.context.font = this.props.font);\n    }\n\n    // Rotate image using worldTransform's rotation component\n    this.context.translate(this.absolutePosition.x, this.absolutePosition.y);\n    this.context.scale(this.scale.x, this.scale.y);\n    this.context.rotate(\n      this.transform.worldTransform.getRotation() * (Math.PI / 180)\n    );\n    this.context.translate(-this.absolutePosition.x, -this.absolutePosition.y);\n\n    this.props.outline &&\n      this.context.strokeText(\n        this.text,\n        this.absolutePosition.x - this._originalWidth / 2,\n        this.absolutePosition.y + this._originalHeight / 2\n      );\n    (this.props.fill || !this.props.outline) &&\n      this.context.fillText(\n        this.text,\n        this.absolutePosition.x - this._originalWidth / 2,\n        this.absolutePosition.y + this._originalHeight / 2\n      );\n  }\n\n  /* istanbul ignore next */\n  _offRender(): void {\n    this.offContext.fillStyle = this.hitColor;\n\n    // Rotate image using worldTransform's rotation component\n    this.offContext.translate(this.absolutePosition.x, this.absolutePosition.y);\n    this.offContext.scale(this.scale.x, this.scale.y);\n    this.offContext.rotate(\n      this.transform.worldTransform.getRotation() * (Math.PI / 180)\n    );\n    this.offContext.translate(\n      -this.absolutePosition.x,\n      -this.absolutePosition.y\n    );\n\n    this.offContext.fillRect(\n      this.absolutePosition.x - this._originalWidth / 2,\n      this.absolutePosition.y - this._originalHeight / 2,\n      this._originalWidth,\n      this._originalHeight\n    );\n  }\n\n  getDimension(): Vector {\n    return new Vector(this._originalWidth, this._originalHeight);\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(229);\n"],"names":["root","factory","exports","module","define","amd","self","Constant","Math","PI","Handle","element","width","height","frameId","HTMLDivElement","this","canvasElement","document","createElement","clientWidth","clientHeight","appendChild","body","context","getContext","OffscreenCanvas","offCanvasElement","offContext","draw","drawing","stop","render","window","cancelAnimationFrame","requestAnimationFrame","bind","Canvas","Random","floor","random","toString","rgbToHex","rgb","Color","_componentToHex","c","hex","length","debugPoint","key","point","props","frames","Debug","limitDebugCalls","debugCalls","push","debugFunction","_debugPoint","arguments","canvas","clone","center","fillStyle","color","beginPath","arc","x","y","radius","fill","debugLine","from","to","_debugLine","strokeStyle","lineWidth","moveTo","lineTo","stroke","show","debug","call","save","restore","shift","globalUpdate","pointers","rootNode","Empty","Vector","Zero","sceneGraph","colorToNode","_registerEvents","getRelativePosition","ev","canvasOffset","getBoundingClientRect","clientX","left","clientY","top","updatePointer","position","pointer","find","pntr","id","pointerId","removePointer","splice","findIndex","currHitNode","prevHitNode","onpointerdown","_getHitNode","onpointermove","pointerType","hitNode","onpointerup","onpointerout","onclick","oncontextmenu","preventDefault","getImageData","data","clearRect","transform","childs","forEach","child","updateWorldTransform","node","add","Node","parent","setContext","setDrawing","setHitColor","cNode","remove","nodeOrID","currentNode","queue","indexOf","_debugSceneGraph","indent","console","log","order","Drawing","controlPoints","Transform","Unit","registeredEvents","zIndex","sort","a","b","newParent","map","absolutePosition","rotation","degrees","localRotation","scale","hitColor","on","eventKey","callback","_render","offRender","_offRender","method","args","dispose","max","Dimension","value","_multiply","another","result","Matrix","Array","i","j","sum","k","multiply","multiplyInPlace","getRotation","atan2","Identity","Multiply","matrix1","matrix2","_position","_localRotation","_rotation","_scale","_parent","localTrasform","worldTransform","refControlPoints","relativeControlPoints","index","newPosition","newRotation","newScale","controlPoint","subtract","applyTransform","_updateWorldTransform","parentWorldTransform","cos","sin","TAU","toFixed","arg1","arg2","addInPlace","subtractInPlace","rotate","pivot","cosT","sinT","rotateInPlace","tmpX","tmpY","matrix","transformInPlace","Midpoint","vector1","vector2","Distance","sqrt","pow","Bounds","vectors","minVec","Number","MAX_SAFE_INTEGER","maxVec","MIN_SAFE_INTEGER","vector","Average","sumX","sumY","minXOrCanvas","maxX","minY","maxY","Lerp","start","end","amount","minor","major","outlineColor","fillColor","create","outlineWidth","outlineDashSegments","setLineDash","shadowColor","shadowBlur","shadowOffset","staticShadow","shadowOffsetX","shadowOffsetY","ellipse","outline","getDimension","Ellipse","source","_source","Image","src","crossOrigin","translate","topLeft","drawImage","fillRect","_from","_to","lineCap","lineDashSegments","Line","offset","colors","weights","gradient","delta","AUTO","createLinearGradient","addColorStop","LinearGradient","vertices","closePath","bounds","abs","Polygon","fromOffset","fromRadius","toOffset","toRadius","fromCenter","toCenter","createRadialGradient","RadialGradient","Rectangle","text","textMetricContext","font","_originalWidth","measureText","_originalHeight","_text","strokeText","fillText","Text","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__"],"sourceRoot":""}